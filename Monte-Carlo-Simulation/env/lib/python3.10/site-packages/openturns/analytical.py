# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""Analytical uncertainty propagation algorithms."""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _analytical
else:
    import _analytical

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _analytical.delete_SwigPyIterator

    def value(self):
        return _analytical.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _analytical.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _analytical.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _analytical.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _analytical.SwigPyIterator_equal(self, x)

    def copy(self):
        return _analytical.SwigPyIterator_copy(self)

    def next(self):
        return _analytical.SwigPyIterator_next(self)

    def __next__(self):
        return _analytical.SwigPyIterator___next__(self)

    def previous(self):
        return _analytical.SwigPyIterator_previous(self)

    def advance(self, n):
        return _analytical.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _analytical.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _analytical.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _analytical.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _analytical.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _analytical.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _analytical.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _analytical:
_analytical.SwigPyIterator_swigregister(SwigPyIterator)
import openturns.base
import openturns.common
import openturns.typ
import openturns.statistics
import openturns.graph
import openturns.func
import openturns.geom
import openturns.iterative_statistics
import openturns.diff
import openturns.optim
import openturns.experiment
import openturns.solver
import openturns.algo
import openturns.model_copula
import openturns.metamodel
import openturns.weightedexperiment
import openturns.orthogonalbasis
import openturns.randomvector
import openturns.transformation
class AnalyticalResult(openturns.common.PersistentObject):
    r"""
    Analytical result.

    Available constructors:
        AnalyticalResult(*designPoint, limitStateVariable, isInFailureSpace*)

    Notes
    -----
    Structure created by the method run() of the :class:`~openturns.Analytical`
    class and obtained thanks to its method getAnalyticalResult().

    Parameters
    ----------
    designPoint : sequence of float
        Design point in the standard space resulting from the optimization
        algorithm.
    limitStateVariable : :class:`~openturns.RandomVector`
        Event of which the probability is calculated.
    isInFailureSpace : bool
        Indicates whether the origin of the standard space is in the failure space.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.AnalyticalResult_getClassName(self)
    ELLIPTICAL = _analytical.AnalyticalResult_ELLIPTICAL
    CLASSICAL = _analytical.AnalyticalResult_CLASSICAL
    PHYSICAL = _analytical.AnalyticalResult_PHYSICAL

    def getStandardSpaceDesignPoint(self):
        r"""
        Accessor to the design point in the standard space.

        Returns
        -------
        designPoint : :class:`~openturns.Point`
            Design point in the standard space resulting from the optimization
            algorithm.
        """
        return _analytical.AnalyticalResult_getStandardSpaceDesignPoint(self)

    def setStandardSpaceDesignPoint(self, standardSpaceDesignPoint):
        r"""
        Accessor to the design point in the standard space.

        Parameters
        ----------
        designPoint : sequence of float
            Design point in the standard space resulting from the optimization
            algorithm.
        """
        return _analytical.AnalyticalResult_setStandardSpaceDesignPoint(self, standardSpaceDesignPoint)

    def getPhysicalSpaceDesignPoint(self):
        r"""
        Accessor to the design point in the physical space.

        Returns
        -------
        designPoint : :class:`~openturns.Point`
            Design point in the physical space resulting from the optimization
            algorithm.
        """
        return _analytical.AnalyticalResult_getPhysicalSpaceDesignPoint(self)

    def getLimitStateVariable(self):
        r"""
        Accessor to the event of which the probability is calculated.

        Returns
        -------
        limitStateVariable : :class:`~openturns.RandomVector`
            Event of which the probability is calculated.
        """
        return _analytical.AnalyticalResult_getLimitStateVariable(self)

    def getIsStandardPointOriginInFailureSpace(self):
        r"""
        Accessor to know if the standard point origin is in the failure space.

        Returns
        -------
        isInFailureSpace : bool
            Indicates whether the origin of the standard space is in the failure space.
        """
        return _analytical.AnalyticalResult_getIsStandardPointOriginInFailureSpace(self)

    def setIsStandardPointOriginInFailureSpace(self, isStandardPointOriginInFailureSpace):
        r"""
        Accessor to specify if the standard point origin is in the failure space.

        Parameters
        ----------
        isInFailureSpace : bool
            Indicates whether the origin of the standard space is in the failure space.
        """
        return _analytical.AnalyticalResult_setIsStandardPointOriginInFailureSpace(self, isStandardPointOriginInFailureSpace)

    def getMeanPointInStandardEventDomain(self):
        r"""
        Accessor to the mean point in the standard event domain.

        Returns
        -------
        meanPoint : :class:`~openturns.Point`
            Mean point of the standard space distribution restricted to the event
            domain:
            :math:`\displaystyle \frac{1}{E_1(-\beta)}\int_{\beta}^{\infty} u_1 p_1(u_1)\di{u_1}`
            where :math:`E_1` is the spheric univariate distribution of the standard
            space and :math:`\beta` the reliability index.
        """
        return _analytical.AnalyticalResult_getMeanPointInStandardEventDomain(self)

    def setMeanPointInStandardEventDomain(self, meanPointInStandardEventDomain):
        r"""
        Accessor to the mean point in the standard event domain.

        Parameters
        ----------
        meanPoint : sequence of float
            Mean point of the standard space distribution restricted to the event
            domain:
            :math:`\displaystyle \frac{1}{E_1(-\beta)}\int_{\beta}^{\infty} u_1 p_1(u_1)\di{u_1}`
            where :math:`E_1` is the spheric univariate distribution of the standard
            space and :math:`\beta` the reliability index.
        """
        return _analytical.AnalyticalResult_setMeanPointInStandardEventDomain(self, meanPointInStandardEventDomain)

    def getImportanceFactors(self, *args):
        r"""
        Accessor to the importance factors.

        Refer :ref:`importance_form`.

        Parameters
        ----------
        type : int, optional
            - When *ot.AnalyticalResult.ELLIPTICAL*, the importance factors
              are evaluated as the square of the co-factors of the design point in the
              elliptical space of the iso-probabilistic transformation (Y-space).

            - When *ot.AnalyticalResult.CLASSICAL* they are evaluated as the square of
              the co-factors of the design point in the U-space.

            - When *ot.AnalyticalResult.PHYSICAL*, the importance factors are evaluated
              as the square of the physical sensitivities.

            By default *type = ot.AnalyticalResult.ELLIPTICAL*.

        Notes
        -----
        - If the importance factors are evaluated as the square of the
          co-factors of the design point in the U-space :

          .. math::

            \alpha_i^2 = \frac{(u_i^*)^2}
                              {\beta_{HL}^2}

        - If the importance factors are evaluated as the square of the co-factors of the
          design point in the Y-space :

          .. math::

            \alpha_i^2 = \frac{(y_i^*)^2}
                              {\|\vect{y}^*\|^2}

          where

          .. math::

            Y^* = \left(
                  \begin{array}{c}
                      E^{-1}\circ F_1(X_1^*) \\
                      E^{-1}\circ F_2(X_2^*) \\
                      \vdots \\
                      E^{-1}\circ F_n(X_n^*)
                  \end{array}
                  \right)

          with :math:`\vect{X}^*` is the design point in the physical space and :math:`E`
          the univariate standard CDF of the elliptical space. In the case where the
          input distribution of :math:`\vect{X}` has an elliptical copula
          :math:`C_E`, then :math:`E` has the same type as :math:`C_E`.
          In the case where the input distribution of :math:`\vect{X}` has a copula
          :math:`C` which is not elliptical, then :math:`E=\Phi` where :math:`\Phi`
          is the CDF of the standard normal.

        - If the importance factors are evaluated as the square of the physical sensitivities :

          .. math::
              \alpha_i^2 = \displaystyle \frac{s_i^2}{{\|s\|}^2}

          where

          .. math::
              s_i = \displaystyle \frac{\partial \beta}{\partial x_i} (x^*)
                  = \sum_{j=1}^n \frac{\partial \beta}{\partial u_i} \frac{\partial u_j}{\partial x_i} (x^*)

        Returns
        -------
        factors : :class:`~openturns.PointWithDescription`
            Sequence containing the importance factors with a description for each
            component.
        """
        return _analytical.AnalyticalResult_getImportanceFactors(self, *args)

    def drawImportanceFactors(self, *args):
        r"""
        Draw the importance factors.

        Parameters
        ----------
        type : int, optional
            See :meth:`getImportanceFactors`

        Returns
        -------
        graph : :class:`~openturns.Graph`
            Pie of the importance factors of the probabilistic variables.
        """
        return _analytical.AnalyticalResult_drawImportanceFactors(self, *args)

    def getHasoferReliabilityIndex(self):
        r"""
        Accessor to the Hasofer Reliability Index.

        Returns
        -------
        index : float
            Hasofer Reliability Index which is the distance of the design point from
            the origin of the standard space :math:`\beta_{HL}=||\vect{u}^*||`.
        """
        return _analytical.AnalyticalResult_getHasoferReliabilityIndex(self)

    def getHasoferReliabilityIndexSensitivity(self):
        r"""
        Accessor to the sensitivities of the Hasofer Reliability Index.

        Refer to :ref:`sensitivity_form`.

        Returns
        -------
        sensitivity : :class:`~openturns.PointWithDescription`
            Sequence containing the sensitivities of the Hasofer Reliability Index to
            the parameters of the probabilistic input vector (marginals and dependence
            structure) with a description for each component.
        """
        return _analytical.AnalyticalResult_getHasoferReliabilityIndexSensitivity(self)

    def getOptimizationResult(self):
        r"""
        Accessor to the result of the optimization problem.

        Returns
        -------
        result : :class:`~openturns.OptimizationResult`
            Contains the design point in the standard space and information concerning
            the convergence of the optimization algorithm.
        """
        return _analytical.AnalyticalResult_getOptimizationResult(self)

    def setOptimizationResult(self, optimizationResult):
        r"""
        Accessor to the result of the optimization problem.

        Parameters
        ----------
        result : :class:`~openturns.OptimizationResult`
            Contains the design point in the standard space and information concerning
            the convergence of the optimization algorithm.
        """
        return _analytical.AnalyticalResult_setOptimizationResult(self, optimizationResult)

    def drawHasoferReliabilityIndexSensitivity(self, *args):
        r"""
        Draw the sensitivity of the Hasofer Reliability Index.

        Parameters
        ----------
        width : float, optional
            Value to calculate the shift position of the :class:`~openturns.BarPlot`.
            By default it is 1.0.

        Returns
        -------
        graphCollection : sequence of two :class:`~openturns.Graph` containing a barplot
            The first graph drawing the sensitivity of the Hasofer Reliability Index to
            the parameters of the marginals of the probabilistic input vector.
            The second graph drawing the sensitivity of the Hasofer Reliability Index
            to the parameters of the dependence structure of the probabilistic input
            vector.
        """
        return _analytical.AnalyticalResult_drawHasoferReliabilityIndexSensitivity(self, *args)

    def __repr__(self):
        return _analytical.AnalyticalResult___repr__(self)

    def __init__(self, *args):
        _analytical.AnalyticalResult_swiginit(self, _analytical.new_AnalyticalResult(*args))
    __swig_destroy__ = _analytical.delete_AnalyticalResult

# Register AnalyticalResult in _analytical:
_analytical.AnalyticalResult_swigregister(AnalyticalResult)
class Analytical(openturns.common.PersistentObject):
    r"""
    Base class to evaluate the probability of failure of a system.

    Available constructors:
        Analytical(*nearestPointAlgorithm, event, physicalStartingPoint*)

    Parameters
    ----------
    nearestPointAlgorithm : :class:`~openturns.OptimizationAlgorithm`
        Optimization algorithm used to research the design point.
    event : :class:`~openturns.RandomVector`
        Failure event.
    physicalStartingPoint : sequence of float
        Starting point of the optimization algorithm, declared in the physical
        space.

    Notes
    -----
    Used in reliability analysis, Analytical is a base class for the approximation
    methods :class:`~openturns.FORM` and :class:`~openturns.SORM` enabling to
    evaluate the failure probability of a system.
    A failure event is defined as follows :
    :math:`\cD_f = \{\vect{X} \in \Rset^n \, | \, g(\vect{X},\vect{d}) \le 0\}`
    where :math:`\vect{X}` denotes a random input vector representing the sources
    of uncertainties, :math:`\vect{d}` is a determinist vector representing the
    fixed variables. :math:`g(\vect{X},\vect{d})` is the limit state function of
    the model separating the failure domain from the safe domain.
    Considering :math:`f_\vect{X}(\vect{x})` the joint probability density function
    of the random variables :math:`\vect{X}`, the probability of failure of the
    event :math:`\cD_f` is :

    .. math::

        P_f = \int_{g(\vect{X},\vect{d})\le 0}f_\vect{X}(\vect{x})\di{\vect{x}}

    The analytical methods use an isoprobabilistic transformation to move from
    the physical space to the standard normal space (U-space) where distributions
    are spherical (invariant by rotation by definition), with zero mean, unit
    variance and unit correlation matrix. The usual isoprobabilistic
    transformations are the Generalized Nataf transformation and the Rosenblatt one.

    In that new U-space, the event has the new expression defined
    from the transformed limit state function of the model
    :math:`G : \cD_f = \{\vect{U} \in \Rset^n \, | \, G(\vect{U}\,,\,\vect{d}) \le 0\}`
    and its boundary :
    :math:`\{\vect{U} \in \Rset^n \, | \,G(\vect{U}\,,\,\vect{d}) = 0\}`.
    Then, the event probability :math:`P_f` rewrites :

    .. math::

        P_f = \Prob{G(\vect{U}\,,\,\vect{d})\leq 0}
            = \int_{\Rset^n} \boldsymbol{1}_{G(\vect{u}\,,\,\vect{d}) \leq 0}\,f_{\vect{U}}(\vect{u})\di{\vect{u}}

    where :math:`f_{\vect{U}}` is the density function of the distribution in the
    standard space.

    The analytical methods rely on the assumption that most of the contribution
    to :math:`P_f` comes from points located in the vicinity of a particular point
    :math:`P^*`, the **design point**, defined in the U-space as the point located
    on the limit state surface verifying the event of maximum likelihood. Given the
    probabilistic characteristics of the U-space, :math:`P^*` has a geometrical
    interpretation: it is the point located on the event boundary and at minimal
    distance from the origin of the U-space. Thus, considering :math:`\vect{u}^*`
    its coordinates in the U-space, the design point is the result of the
    constrained optimization problem :

    .. math::

        \vect{u}^* = argmin \{||\vect{u}|| \, | \, G(\vect{u}) = 0 \}

    Then the limit state surface is approximated in the standard space by a linear
    surface (:class:`~openturns.FORM`) or by a quadratic surface
    (:class:`~openturns.SORM`) at the design point in order to evaluate the
    failure probability. For more information on this evaluation, see the
    documentation associated with these two methods.

    The result of the optimization problem is recoverable thanks to the method
    :meth:`getAnalyticalResult`.

    The unicity and the strongness of the design point can be checked thanks to the
    :class:`Strong Maximum Test <openturns.StrongMaximumTest>`.

    See also
    --------
    FORM, SORM, StrongMaximumTest, Event, StandardEvent, AnalyticalResult

    Examples
    --------
    >>> import openturns as ot
    >>> myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3*E*I)'])
    >>> myDistribution = ot.Normal([50.0, 1.0, 10.0, 5.0], [1.0]*4, ot.IdentityMatrix(4))
    >>> vect = ot.RandomVector(myDistribution)
    >>> output = ot.CompositeRandomVector(myFunction, vect)
    >>> myEvent = ot.ThresholdEvent(output, ot.Less(), -3.0)
    >>> # We create an OptimizationAlgorithm algorithm
    >>> myOptim = ot.AbdoRackwitz()
    >>> myAlgo = ot.Analytical(myOptim, myEvent, [50.0, 1.0, 10.0, 5.0])
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.Analytical_getClassName(self)

    def getPhysicalStartingPoint(self):
        r"""
        Accessor to the starting point of the optimization algorithm.

        Returns
        -------
        point : :class:`~openturns.Point`
            Starting point of the optimization algorithm, declared in the physical
            space.
        """
        return _analytical.Analytical_getPhysicalStartingPoint(self)

    def setPhysicalStartingPoint(self, physicalStartingPoint):
        r"""
        Accessor to the starting point of the optimization algorithm.

        Parameters
        ----------
        point : sequence of float
            Starting point of the optimization algorithm, declared in the physical
            space.
        """
        return _analytical.Analytical_setPhysicalStartingPoint(self, physicalStartingPoint)

    def getEvent(self):
        r"""
        Accessor to the event of which the probability is calculated.

        Returns
        -------
        event : :class:`~openturns.RandomVector`
            Event of which the probability is calculated.
        """
        return _analytical.Analytical_getEvent(self)

    def setEvent(self, event):
        r"""
        Accessor to the event of which the probability is calculated.

        Parameters
        ----------
        event : :class:`~openturns.RandomVector`
            Event of which the probability is calculated.
        """
        return _analytical.Analytical_setEvent(self, event)

    def getNearestPointAlgorithm(self):
        r"""
        Accessor to the optimization algorithm used to find the design point.

        Returns
        -------
        algorithm : :class:`~openturns.OptimizationAlgorithm`
             Optimization algorithm used to research the design point.
        """
        return _analytical.Analytical_getNearestPointAlgorithm(self)

    def setNearestPointAlgorithm(self, solver):
        r"""
        Accessor to the optimization algorithm used to find the design point.

        Parameters
        ----------
        algorithm : :class:`~openturns.OptimizationAlgorithm`
             Optimization algorithm used to research the design point.
        """
        return _analytical.Analytical_setNearestPointAlgorithm(self, solver)

    def getAnalyticalResult(self):
        r"""
        Accessor to the result.

        Returns
        -------
        result : :class:`~openturns.AnalyticalResult`
            Result structure which contains the results of the optimisation problem.
        """
        return _analytical.Analytical_getAnalyticalResult(self)

    def __repr__(self):
        return _analytical.Analytical___repr__(self)

    def run(self):
        r"""
        Perform the research of the design point.

        Notes
        -----
        Performs the research of the design point and creates a
        :class:`~openturns.AnalyticalResult`, the structure result which is
        accessible with the method :meth:`getAnalyticalResult`.
        """
        return _analytical.Analytical_run(self)

    def __init__(self, *args):
        _analytical.Analytical_swiginit(self, _analytical.new_Analytical(*args))
    __swig_destroy__ = _analytical.delete_Analytical

# Register Analytical in _analytical:
_analytical.Analytical_swigregister(Analytical)
class FORMResult(AnalyticalResult):
    r"""
    Result of a FORM analysis.

    Available constructors:
        FORMResult(*designPoint, limitStateVariable, isInFailureSpace*)

    Notes
    -----
    Structure created by the method run() of the :class:`~openturns.FORM`
    class and obtained thanks to its method getResult().

    Parameters
    ----------
    designPoint : sequence of float
        Design point in the standard space resulting from the optimization
        algorithm.
    limitStateVariable : :class:`~openturns.RandomVector`
        Event of which the probability is calculated.
    isInFailureSpace : bool
        Indicates whether the origin of the standard space is in the failure space.


    See also
    --------
    Analytical, AnalyticalResult, SORM, SORMResult, FORM, StrongMaximumTest
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.FORMResult_getClassName(self)

    def getEventProbability(self):
        r"""
        Accessor to the failure probability :math:`P_f`.

        Returns
        -------
        probability : positive float
            The FORM failure probability :math:`P_f`.
        """
        return _analytical.FORMResult_getEventProbability(self)

    def getGeneralisedReliabilityIndex(self):
        r"""
        Accessor to the Generalised Reliability Index.

        Returns
        -------
        index : float
            Generalised reliability index :math:`\beta_g` from the FORM failure
            probability is equal to :math:`\pm` the Hasofer reliability index
            :math:`\beta_{HL}` according to the fact the standard space center
            fulfills the event or not.
        """
        return _analytical.FORMResult_getGeneralisedReliabilityIndex(self)

    def getEventProbabilitySensitivity(self):
        r"""
        Accessor to the sentivities of the FORM failure probability :math:`P_f`.

        Returns
        -------
        sentivities : :class:`~openturns.Point`
            Sentivities of the FORM failure probability with regards to the parameters
            of the probabilistic input vector and to parameters of the dependence
            structure of the probabilistic input vector.
        """
        return _analytical.FORMResult_getEventProbabilitySensitivity(self)

    def drawEventProbabilitySensitivity(self, *args):
        r"""
        Draw the sensitivities of the FORM failure probability.

        Parameters
        ----------
        width : float, optional
            Value to calculate the shift position of the :class:`~openturns.BarPlot`.
            By default it is 1.0.

        Returns
        -------
        graphCollection : list of two :class:`~openturns.Graph` containing a barplot
            The first graph drawing the sensitivities of the FORM failure probability
            with regards to the parameters of the probabilistic input vector.
            The second graph drawing the sensitivities of the FORM failure probability
            with regards to the parameters of the dependence structure of the
            probabilistic input vector.
        """
        return _analytical.FORMResult_drawEventProbabilitySensitivity(self, *args)

    def __repr__(self):
        return _analytical.FORMResult___repr__(self)

    def __init__(self, *args):
        _analytical.FORMResult_swiginit(self, _analytical.new_FORMResult(*args))
    __swig_destroy__ = _analytical.delete_FORMResult

# Register FORMResult in _analytical:
_analytical.FORMResult_swigregister(FORMResult)
class FORM(Analytical):
    r"""
    First Order Reliability Method (FORM).

    Refer to :ref:`form_approximation`.

    Available constructors:
        FORM(*nearestPointAlgorithm, event, physicalStartingPoint*)

    Parameters
    ----------
    nearestPointAlgorithm : :class:`~openturns.OptimizationAlgorithm`
        Optimization algorithm used to research the design point.
    event : :class:`~openturns.RandomVector`
        Failure event.
    physicalStartingPoint : sequence of float
        Starting point of the optimization algorithm, declared in the physical
        space.

    Notes
    -----
    See :class:`~openturns.Analytical` for the description of the first steps of
    the FORM analysis.

    The First Order Reliability Method (FORM) consists in linearizing the limit state
    function :math:`G(\vect{U}\,,\,\vect{d})` at the design point, denoted
    :math:`P^*`, which is the point on the limit state surface
    :math:`G(\vect{U}\,,\,\vect{d})=0` that is closest to the origin of the
    standard space.

    Then, the probability :math:`P_f` where the limit state surface has been
    approximated by a linear surface (hyperplane) can be obtained exactly, thanks
    to the rotation invariance of the standard distribution :math:`f_{\vect{U}}` :

    .. math::

        P_f = \left\{
                  \begin{array}{ll}
                  \displaystyle E(-\beta_{HL})
                  & \text{if the origin of the }\vect{u}\text{-space lies in the domain }\cD_f \\
                  \displaystyle E(+\beta_{HL}) & \text{otherwise}
                  \end{array}
              \right.

    where :math:`\beta_{HL}` is the Hasofer-Lind reliability index, defined as the
    distance of the design point :math:`\vect{u}^*` to the origin of the standard
    space and :math:`E` the marginal cumulative density function of the spherical
    distributions in the standard space.

    The evaluation of the failure probability is stored in the data structure
    :class:`~openturns.FORMResult` recoverable with the :meth:`getResult` method.

    See also
    --------
    Analytical, AnalyticalResult, SORM, StrongMaximumTest, FORMResult

    Examples
    --------
    >>> import openturns as ot
    >>> myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3*E*I)'])
    >>> myDistribution = ot.Normal([50.0, 1.0, 10.0, 5.0], [1.0]*4, ot.IdentityMatrix(4))
    >>> vect = ot.RandomVector(myDistribution)
    >>> output = ot.CompositeRandomVector(myFunction, vect)
    >>> event = ot.ThresholdEvent(output, ot.Less(), -3.0)
    >>> # We create an OptimizationAlgorithm algorithm
    >>> solver = ot.AbdoRackwitz()
    >>> algo = ot.FORM(solver, event, [50.0, 1.0, 10.0, 5.0])
    >>> algo.run()
    >>> result = algo.getResult()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.FORM_getClassName(self)

    def getResult(self):
        r"""
        Accessor to the result of FORM.

        Returns
        -------
        result : :class:`~openturns.FORMResult`
            Structure containing all the results of the FORM analysis.
        """
        return _analytical.FORM_getResult(self)

    def setResult(self, formResult):
        r"""
        Accessor to the result of FORM.

        Parameters
        ----------
        result : :class:`~openturns.FORMResult`
            Structure containing all the results of the FORM analysis.
        """
        return _analytical.FORM_setResult(self, formResult)

    def __repr__(self):
        return _analytical.FORM___repr__(self)

    def run(self):
        r"""
        Evaluate the failure probability.

        Notes
        -----
        Evaluate the failure probability and create a :class:`~openturns.FORMResult`,
        the structure result which is accessible with the method :meth:`getResult`.
        """
        return _analytical.FORM_run(self)

    def __init__(self, *args):
        _analytical.FORM_swiginit(self, _analytical.new_FORM(*args))
    __swig_destroy__ = _analytical.delete_FORM

# Register FORM in _analytical:
_analytical.FORM_swigregister(FORM)
class SORMResult(AnalyticalResult):
    r"""
    Result of a SORM analysis.

    Available constructors:
        SORMResult(*designPoint, limitStateVariable, isInFailureSpace*)

    Notes
    -----
    Structure created by the method run() of the :class:`~openturns.SORM`
    class and obtained thanks to its method getResult().

    Parameters
    ----------
    designPoint : sequence of float
        Design point in the standard space resulting from the optimization
        algorithm.
    limitStateVariable : :class:`~openturns.RandomVector`
        Event of which the probability is calculated.
    isInFailureSpace : bool
        Indicates whether the origin of the standard space is in the failure space.


    See also
    --------
    Analytical, AnalyticalResult, FORM, FORMResult, StrongMaximumTest
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.SORMResult_getClassName(self)

    def getEventProbabilityBreitung(self):
        r"""
        Accessor to the failure probability :math:`P_{Breitung}`.

        Returns
        -------
        probability : positive float
            The SORM failure probability :math:`P_{Breitung}` according to the
            :ref:`Breitung <Breitung_formula>` approximation.
        """
        return _analytical.SORMResult_getEventProbabilityBreitung(self)

    def getEventProbabilityHohenbichler(self):
        r"""
        Accessor to the failure probability :math:`P_{Hohenbichler}`.

        Returns
        -------
        probability : positive float
            The SORM failure probability :math:`P_{Hohenbichler}` according to the
            :ref:`Hohenbichler <Hohenbichler_formula>` approximation.
        """
        return _analytical.SORMResult_getEventProbabilityHohenbichler(self)

    def getEventProbabilityTvedt(self):
        r"""
        Accessor to the failure probability :math:`P_{Tvedt}`.

        Returns
        -------
        probability : positive float
            The SORM failure probability :math:`P_{Tvedt}` according to the
            :ref:`Tvedt <Tvedt_formula>` approximation.
        """
        return _analytical.SORMResult_getEventProbabilityTvedt(self)

    def getGeneralisedReliabilityIndexBreitung(self):
        r"""
        Accessor to the Generalised Reliability Index Breitung.

        Returns
        -------
        index : float
            Generalised reliability index evaluated from the Breitung SORM failure
            probability.

            .. math::

                \beta_{Breitung} = \left \{
                \begin{array}{ll}
                \displaystyle -\Phi(P_{Breitung})
                & \text{if the standard space origin is not in the failure space} \\
                \displaystyle \Phi(P_{Breitung}) & \text{otherwise}
                \end{array}
                \right.
        """
        return _analytical.SORMResult_getGeneralisedReliabilityIndexBreitung(self)

    def getGeneralisedReliabilityIndexHohenbichler(self):
        r"""
        Accessor to the Generalised Reliability Index Hohenbichler.

        Returns
        -------
        index : float
            Generalised reliability index evaluated from the Hohenbichler SORM failure
            probability.

            .. math::

                \beta_{Hohenbichler} = \left \{
                \begin{array}{ll}
                \displaystyle -\Phi(P_{Hohenbichler})
                & \text{if the standard space origin is not in the failure space} \\
                \displaystyle \Phi(P_{Hohenbichler}) & \text{otherwise}
                \end{array}
                \right.
        """
        return _analytical.SORMResult_getGeneralisedReliabilityIndexHohenbichler(self)

    def getGeneralisedReliabilityIndexTvedt(self):
        r"""
        Accessor to the Generalised Reliability Index Tvedt.

        Returns
        -------
        index : float
            Generalised reliability index evaluated from the Tvedt SORM failure
            probability.

            .. math::

                \beta_{Tvedt} = \left \{
                \begin{array}{ll}
                \displaystyle -\Phi(P_{Tvedt})
                & \text{if the standard space origin is not in the failure space} \\
                \displaystyle \Phi(P_{Tvedt}) & \text{otherwise}
                \end{array}
                \right.
        """
        return _analytical.SORMResult_getGeneralisedReliabilityIndexTvedt(self)

    def getSortedCurvatures(self):
        r"""
        Accessor to the sorted curvatures.

        Returns
        -------
        curvatures : :class:`~openturns.Point`
            Curvatures of the standard limite state function at the standard design
            point :math:`(\kappa_i)_{1 \leq i \leq n-1}` with :math:`n` the dimension
            of the random vector :math:`\vect{X}`.
        """
        return _analytical.SORMResult_getSortedCurvatures(self)

    def __repr__(self):
        return _analytical.SORMResult___repr__(self)

    def __str__(self, *args):
        return _analytical.SORMResult___str__(self, *args)

    def __init__(self, *args):
        _analytical.SORMResult_swiginit(self, _analytical.new_SORMResult(*args))
    __swig_destroy__ = _analytical.delete_SORMResult

# Register SORMResult in _analytical:
_analytical.SORMResult_swigregister(SORMResult)
class SORM(Analytical):
    r"""
    Second Order Reliability Method (SORM).

    Refer to :ref:`sorm_approximation`.

    Available constructors:
        SORM(*nearestPointAlgorithm, event, physicalStartingPoint*)

    Parameters
    ----------
    nearestPointAlgorithm : :class:`~openturns.OptimizationAlgorithm`
        Optimization algorithm used to research the design point.
    event : :class:`~openturns.RandomVector`
        Failure event.
    physicalStartingPoint : sequence of float
        Starting point of the optimization algorithm, declared in the physical
        space.

    Notes
    -----
    See :class:`~openturns.Analytical` for the description of the first steps of
    the SORM analysis.

    The Second Order Reliability Method (SORM) consists in approximating the limit
    state surface in U-space at the design point :math:`P^*` by a quadratic
    surface. SORM is usually more accurate than FORM e.g. in case when the event
    boundary is highly curved.

    Let us denote by :math:`n` the dimension of the random vector :math:`\vect{X}`
    and :math:`(\kappa_i)_{1 \leq i \leq n-1}` the :math:`n-1` main curvatures of
    the limit state function at the design point in the standard space.

    Several approximations of the failure probability :math:`P_f` are available in
    the library, and detailed here in the case where the origin
    of the standard space does not belong to the failure domain:

    - Breitung's formula:

      .. _Breitung_formula:

      .. math ::

          P_{Breitung} = E(-\beta_{HL})\prod_{i=1}^{n-1} \frac{1}{\sqrt{1 + \beta_{HL}\kappa_i}}

      :math:`E` the marginal cumulative density function of the spherical
      distributions in the standard space and :math:`\beta_{HL}` is the Hasofer-Lind
      reliability index, defined as the distance of the design point
      :math:`\vect{u}^*` to the origin of the standard space.

    - Hohenbichler's formula is an approximation of the previous equation:

      .. _Hohenbichler_formula:

      .. math ::

          \displaystyle P_{Hohenbichler} = \Phi(-\beta_{HL})
           \prod_{i=1}^{n-1} \left(
                             1 + \frac{\phi(\beta_{HL})}{\Phi(-\beta_{HL})}\kappa_i
                             \right) ^{-1/2}

      where :math:`\Phi` is the cumulative distribution function of the
      standard 1D normal distribution and :math:`\phi` is the standard Gaussian
      probability density function.

    - Tvedt's formula:

      .. _Tvedt_formula:

      .. math ::

          \left\{
            \begin{array}{lcl}
              \displaystyle P_{Tvedt} & = & A_1 + A_2 + A_3 \\
              \displaystyle A_1 & = & \displaystyle
                \Phi(-\beta_{HL}) \prod_{i=1}^{N-1} \left( 1 + \beta_{HL} \kappa_i \right) ^{-1/2}\\
              \displaystyle A_2 & = & \displaystyle
                \left[ \beta_{HL} \Phi(-\beta_{HL}) - \phi(\beta_{HL}) \right]
                \left[ \prod_{j=1}^{N-1} \left( 1 + \beta_{HL} \kappa_i \right) ^{-1/2} -
                       \prod_{j=1}^{N-1} \left( 1 + (1 + \beta_{HL}) \kappa_i \right) ^{-1/2}
                \right ] \\
              \displaystyle A_3 & = & \displaystyle (1 + \beta_{HL})
                \left[ \beta_{HL} \Phi(-\beta_{HL}) - \phi(\beta_{HL}) \right]
                \left[ \prod_{j=1}^{N-1} \left( 1 + \beta_{HL} \kappa_i \right) ^{-1/2} -
                       {\cR}e \left( \prod_{j=1}^{N-1} \left( 1 + (i + \beta_{HL}) \kappa_j \right) ^{-1/2}
                \right)\right ]
            \end{array}
          \right.

      where :math:`{\cR}e(z)` is the real part of the complex number :math:`z` and
      :math:`i` the complex number such that :math:`i^2 = -1`.

    The evaluation of the failure probability is stored in the data structure
    :class:`~openturns.SORMResult` recoverable with the :meth:`getResult` method.

    See also
    --------
    Analytical, AnalyticalResult, FORM, StrongMaximumTest, SORMResult

    Examples
    --------
    >>> import openturns as ot
    >>> myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3*E*I)'])
    >>> myDistribution = ot.Normal([50.0, 1.0, 10.0, 5.0], [1.0]*4, ot.IdentityMatrix(4))
    >>> vect = ot.RandomVector(myDistribution)
    >>> output = ot.CompositeRandomVector(myFunction, vect)
    >>> event = ot.ThresholdEvent(output, ot.Less(), -3.0)
    >>> # We create an OptimizationAlgorithm algorithm
    >>> solver = ot.AbdoRackwitz()
    >>> algo = ot.SORM(solver, event, [50.0, 1.0, 10.0, 5.0])
    >>> algo.run()
    >>> result = algo.getResult()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.SORM_getClassName(self)

    def getResult(self):
        r"""
        Accessor to the result of SORM.

        Returns
        -------
        result : :class:`~openturns.SORMResult`
            Structure containing all the results of the SORM analysis.
        """
        return _analytical.SORM_getResult(self)

    def setResult(self, sormResult):
        r"""
        Accessor to the result of SORM.

        Parameters
        ----------
        result : :class:`~openturns.SORMResult`
            Structure containing all the results of the SORM analysis.
        """
        return _analytical.SORM_setResult(self, sormResult)

    def __repr__(self):
        return _analytical.SORM___repr__(self)

    def run(self):
        r"""
        Evaluate the failure probability.

        Notes
        -----
        Evaluate the failure probability and create a :class:`~openturns.SORMResult`,
        the structure result which is accessible with the method :meth:`getResult`.
        """
        return _analytical.SORM_run(self)

    def __init__(self, *args):
        _analytical.SORM_swiginit(self, _analytical.new_SORM(*args))
    __swig_destroy__ = _analytical.delete_SORM

# Register SORM in _analytical:
_analytical.SORM_swigregister(SORM)
class StrongMaximumTest(openturns.common.PersistentObject):
    r"""
    Strong Maximum Test.

    Refer to :ref:`strong_maximum_test`.

    Available constructors:
        StrongMaximumTest(*event, designPoint, importanceLevel, accuracyLevel, confidenceLevel*)

        StrongMaximumTest(*event, designPoint, importanceLevel, accuracyLevel, pointNumber*)

    Parameters
    ----------
    event : :class:`~openturns.StandardEvent`
        Failure event :math:`\cD_f` defining in the standard space (U-space).
    designPoint : sequence of float
        Design point in the standard space resulting from the optimization
        algorithm.
    importanceLevel : float, :math:`0 < \varepsilon < 1`
        Importance level.
    accuracyLevel : float, :math:`\tau > 0`
        Accuracy level. It is recommanded to take :math:`\tau \leq 4`.
    confidenceLevel : positive float, :math:`0 < (1-q) < 1`
        Confidence level.
    pointNumber : int, :math:`N > 0`
        Number of points used to perform the Strong Maximum Test, evaluated by the
        limit state function.

    Notes
    -----
    The Strong Maximum Test helps to evaluate the quality of the design point
    :math:`P^*` resulting from the optimization algorithm launched for example by
    the :class:`~openturns.Analytical` class or its derived classes
    :class:`~openturns.FORM` and :class:`~openturns.SORM`.
    It checks whether the design point computed is :

    - the *true* design point, which means a global maximum point,

    - a *strong* design point, which means that there is no other local maximum
      located on the event boundary and which likelihood is slightly inferior to
      the design point one.

    The Strong Maximum Test will sample the sphere centered on the origin of the
    standard space and of radius :
    :math:`R = \beta_{HL} (1 + \tau \delta_{\varepsilon})` with :math:`\tau > 0`,
    :math:`\delta_{\varepsilon}=\sqrt{1 - 2 \frac{ln(\varepsilon)}{\beta_{HL}^2}} - 1`
    and :math:`\beta_{HL}` the Hasofer-Lind reliability index.

    The number :math:`N` of the simulations sampling the sphere of radius :math:`R`
    is determined to ensure that the test detects with a probability greater than
    :math:`(1-q)` any point of :math:`\cD_f` outside the design point vicinity
    which contribution to :math:`P_f` is not negligeable (i.e. which density value
    in the U-space is greater than :math:`\varepsilon` times the density value at
    the design point).

    See also
    --------
    Analytical, SORM, FORM, SORMResult, FORMResult

    Examples
    --------
    >>> import openturns as ot
    >>> myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3*E*I)'])
    >>> myDistribution = ot.Normal([50.0, 1.0, 10.0, 5.0], [1.0]*4, ot.IdentityMatrix(4))
    >>> vect = ot.RandomVector(myDistribution)
    >>> output = ot.CompositeRandomVector(myFunction, vect)
    >>> myEvent = ot.ThresholdEvent(output, ot.Less(), -3.0)
    >>> # FORM analyse to get the design point
    >>> myAlgo = ot.FORM(ot.AbdoRackwitz(), myEvent, [50.0, 1.0, 10.0, 5.0])
    >>> myAlgo.run()
    >>> FORMresult = myAlgo.getResult()
    >>> designPoint = FORMresult.getStandardSpaceDesignPoint()
    >>> # Strong Max Test
    >>> myStandardEvent = ot.StandardEvent(myEvent)
    >>> myTest = ot.StrongMaximumTest(myStandardEvent, designPoint, 0.15, 3, 0.99)
    >>> myTest.run()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.StrongMaximumTest_getClassName(self)

    def getStandardSpaceDesignPoint(self):
        r"""
        Accessor to the design point in the standard space.

        Returns
        -------
        point : :class:`~openturns.Point`
            Design point in the standard space.
        """
        return _analytical.StrongMaximumTest_getStandardSpaceDesignPoint(self)

    def getEvent(self):
        r"""
        Accessor to the event in the standard space.

        Returns
        -------
        event : :class:`~openturns.StandardEvent`
            Failure event :math:`\cD_f` in the standard space on which is based the
            Strong Maximum Test.
        """
        return _analytical.StrongMaximumTest_getEvent(self)

    def getImportanceLevel(self):
        r"""
        Accessor to the importance level.

        Returns
        -------
        level : float
            Importance level :math:`\varepsilon`.
        """
        return _analytical.StrongMaximumTest_getImportanceLevel(self)

    def getAccuracyLevel(self):
        r"""
        Accessor to the accuracy level.

        Returns
        -------
        accuracy : positive float
            Accuracy level :math:`\tau`.
        """
        return _analytical.StrongMaximumTest_getAccuracyLevel(self)

    def getConfidenceLevel(self):
        r"""
        Accessor to the confidence level.

        Returns
        -------
        level : positive float
            Confidence level :math:`(1-q)`.
        """
        return _analytical.StrongMaximumTest_getConfidenceLevel(self)

    def getDesignPointVicinity(self):
        r"""
        Accessor to the design point vinicity.

        Returns
        -------
        vicinity : float, :math:`v > 0`
            Design point vinicity :math:`v = \frac{1} {1 + \tau \delta_{\varepsilon}}`.
        """
        return _analytical.StrongMaximumTest_getDesignPointVicinity(self)

    def getPointNumber(self):
        r"""
        Accessor to the number of points.

        Returns
        -------
        number : int, :math:`N > 0`
            Number of points used to perform the Strong Maximum Test, evaluated by the
            limit state function.
        """
        return _analytical.StrongMaximumTest_getPointNumber(self)

    def getDeltaEpsilon(self):
        r"""
        Accessor to the parameter :math:`\delta_{\varepsilon}`.

        Returns
        -------
        delta_epsilon : float
            :math:`\delta_{\varepsilon} = \sqrt{1 - 2 \frac{ln(\varepsilon)}{\beta^2}} - 1`.
        """
        return _analytical.StrongMaximumTest_getDeltaEpsilon(self)

    def run(self):
        r"""Perform the Strong Maximum Test."""
        return _analytical.StrongMaximumTest_run(self)

    def getNearDesignPointVerifyingEventPoints(self):
        r"""
        Accessor to the points verifying the event and near of the design point.

        Returns
        -------
        points : :class:`~openturns.Sample`
            The points of the discretized sphere which are inside the vicinity of
            the standard design point and which verify the event.
        """
        return _analytical.StrongMaximumTest_getNearDesignPointVerifyingEventPoints(self)

    def getFarDesignPointVerifyingEventPoints(self):
        r"""
        Accessor to the points verifying the event and far of the design point.

        Returns
        -------
        points : :class:`~openturns.Sample`
            The points of the discretized sphere which are out of the vicinity of
            the standard design point and which verify the event.
        """
        return _analytical.StrongMaximumTest_getFarDesignPointVerifyingEventPoints(self)

    def getNearDesignPointViolatingEventPoints(self):
        r"""
        Accessor to the points not verifying the event and near of the design point.

        Returns
        -------
        point : :class:`~openturns.Sample`
            The points of the discretized sphere which are out of the vicinity of
            the standard design point and which don't verify the event.
        """
        return _analytical.StrongMaximumTest_getNearDesignPointViolatingEventPoints(self)

    def getFarDesignPointViolatingEventPoints(self):
        r"""
        Accessor to the points not verifying the event and far of the design point.

        Returns
        -------
        points : :class:`~openturns.Sample`
            The points of the discretized sphere which are out of the vicinity of
            the standard design point and which don't verify the event.
        """
        return _analytical.StrongMaximumTest_getFarDesignPointViolatingEventPoints(self)

    def getNearDesignPointVerifyingEventValues(self):
        r"""
        Accessor to values of the limit state function.

        Returns
        -------
        values : :class:`~openturns.Sample`
            The values of the limit state function on the points of the
            discretized sphere which are inside the vicinity of the standard design
            point and which verify the event.
        """
        return _analytical.StrongMaximumTest_getNearDesignPointVerifyingEventValues(self)

    def getFarDesignPointVerifyingEventValues(self):
        r"""
        Accessor to values of the limit state function.

        Returns
        -------
        values : :class:`~openturns.Sample`
            The values of the limit state function on the points of the
            discretized sphere which are out of the vicinity of the standard design
            point and which verify the event.
        """
        return _analytical.StrongMaximumTest_getFarDesignPointVerifyingEventValues(self)

    def getNearDesignPointViolatingEventValues(self):
        r"""
        Accessor to values of the limit state function.

        Returns
        -------
        values : :class:`~openturns.Sample`
            The values of the limit state function on the points of the
            discretized sphere which are inside the vicinity of the standard design
            point and which don't verify the event.
        """
        return _analytical.StrongMaximumTest_getNearDesignPointViolatingEventValues(self)

    def getFarDesignPointViolatingEventValues(self):
        r"""
        Accessor to values of the limit state function.

        Returns
        -------
        values : :class:`~openturns.Sample`
            The values of the limit state function on the points of the
            discretized sphere which are out of the vicinity of the standard design
            point and which don't verify the event.
        """
        return _analytical.StrongMaximumTest_getFarDesignPointViolatingEventValues(self)

    def __repr__(self):
        return _analytical.StrongMaximumTest___repr__(self)

    def __init__(self, *args):
        _analytical.StrongMaximumTest_swiginit(self, _analytical.new_StrongMaximumTest(*args))
    __swig_destroy__ = _analytical.delete_StrongMaximumTest

# Register StrongMaximumTest in _analytical:
_analytical.StrongMaximumTest_swigregister(StrongMaximumTest)
class FORMResultCollection(object):
    r"""
    Collection.

    Examples
    --------
    >>> import openturns as ot

    - Collection of **real values**:

    >>> ot.ScalarCollection(2)
    [0,0]
    >>> ot.ScalarCollection(2, 3.25)
    [3.25,3.25]
    >>> vector = ot.ScalarCollection([2.0, 1.5, 2.6])
    >>> vector
    [2,1.5,2.6]
    >>> vector[1] = 4.2
    >>> vector
    [2,4.2,2.6]
    >>> vector.add(3.8)
    >>> vector
    [2,4.2,2.6,3.8]

    - Collection of **complex values**:

    >>> ot.ComplexCollection(2)
    [(0,0),(0,0)]
    >>> ot.ComplexCollection(2, 3+4j)
    [(3,4),(3,4)]
    >>> vector = ot.ComplexCollection([2+3j, 1-4j, 3.0])
    >>> vector
    [(2,3),(1,-4),(3,0)]
    >>> vector[1] = 4+3j
    >>> vector
    [(2,3),(4,3),(3,0)]
    >>> vector.add(5+1j)
    >>> vector
    [(2,3),(4,3),(3,0),(5,1)]

    - Collection of **booleans**:

    >>> ot.BoolCollection(3)
    [0,0,0]
    >>> ot.BoolCollection(3, 1)
    [1,1,1]
    >>> vector = ot.BoolCollection([0, 1, 0])
    >>> vector
    [0,1,0]
    >>> vector[1] = 0
    >>> vector
    [0,0,0]
    >>> vector.add(1)
    >>> vector
    [0,0,0,1]

    - Collection of **distributions**:

    >>> print(ot.DistributionCollection(2))
    [Uniform(a = -1, b = 1),Uniform(a = -1, b = 1)]
    >>> print(ot.DistributionCollection(2, ot.Gamma(2.75, 1.0)))
    [Gamma(k = 2.75, lambda = 1, gamma = 0),Gamma(k = 2.75, lambda = 1, gamma = 0)]
    >>> vector = ot.DistributionCollection([ot.Normal(), ot.Uniform()])
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -1, b = 1)]
    >>> vector[1] = ot.Uniform(-0.5, 1)
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -0.5, b = 1)]
    >>> vector.add(ot.Gamma(2.75, 1.0))
    >>> print(vector)
    [Normal(mu = 0, sigma = 1),Uniform(a = -0.5, b = 1),Gamma(k = 2.75, lambda = 1, gamma = 0)]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _analytical.delete_FORMResultCollection

    def clear(self):
        r"""
        Reset the collection to zero dimension.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.clear()
        >>> x
        class=Point name=Unnamed dimension=0 values=[]
        """
        return _analytical.FORMResultCollection_clear(self)

    def __len__(self):
        return _analytical.FORMResultCollection___len__(self)

    def __eq__(self, rhs):
        return _analytical.FORMResultCollection___eq__(self, rhs)

    def __contains__(self, val):
        return _analytical.FORMResultCollection___contains__(self, val)

    def select(self, marginalIndices):
        r"""
        Selection from indices.

        Parameters
        ----------
        indices : sequence of int
            Indices to select

        Returns
        -------
        coll : sequence
            Sub-collection of values at the selection indices.
        """
        return _analytical.FORMResultCollection_select(self, marginalIndices)

    def __getitem__(self, i):
        return _analytical.FORMResultCollection___getitem__(self, i)

    def __setitem__(self, i, val):
        return _analytical.FORMResultCollection___setitem__(self, i, val)

    def __delitem__(self, i):
        return _analytical.FORMResultCollection___delitem__(self, i)

    def at(self, *args):
        r"""
        Access to an element of the collection.

        Parameters
        ----------
        index : positive int
            Position of the element to access.

        Returns
        -------
        element : type depends on the type of the collection
            Element of the collection at the position *index*.
        """
        return _analytical.FORMResultCollection_at(self, *args)

    def add(self, *args):
        r"""
        Append a component (in-place).

        Parameters
        ----------
        value : type depends on the type of the collection.
            The component to append.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.add(1.)
        >>> print(x)
        [0,0,1]
        """
        return _analytical.FORMResultCollection_add(self, *args)

    def getSize(self):
        r"""
        Get the collection's dimension (or size).

        Returns
        -------
        n : int
            The number of components in the collection.
        """
        return _analytical.FORMResultCollection_getSize(self)

    def resize(self, newSize):
        r"""
        Change the size of the collection.

        Parameters
        ----------
        newSize : positive int
            New size of the collection.

        Notes
        -----
        If the new size is smaller than the older one, the last elements are thrown
        away, else the new elements are set to the default value of the element type.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2, 4)
        >>> print(x)
        [4,4]
        >>> x.resize(1)
        >>> print(x)
        [4]
        >>> x.resize(4)
        >>> print(x)
        [4,0,0,0]
        """
        return _analytical.FORMResultCollection_resize(self, newSize)

    def isEmpty(self):
        r"""
        Tell if the collection is empty.

        Returns
        -------
        isEmpty : bool
            *True* if there is no element in the collection.

        Examples
        --------
        >>> import openturns as ot
        >>> x = ot.Point(2)
        >>> x.isEmpty()
        False
        >>> x.clear()
        >>> x.isEmpty()
        True
        """
        return _analytical.FORMResultCollection_isEmpty(self)

    def find(self, val):
        r"""
        Find the index of a given value.

        Parameters
        ----------
        val : collection value type
            The value to find

        Returns
        -------
        index : int
            The index of the first occurrence of the value,
            or the size of the container if not found.
            When several values match, only the first index is returned.
        """
        return _analytical.FORMResultCollection_find(self, val)

    def __repr__(self):
        return _analytical.FORMResultCollection___repr__(self)

    def __str__(self, *args):
        return _analytical.FORMResultCollection___str__(self, *args)

    def __init__(self, *args):
        _analytical.FORMResultCollection_swiginit(self, _analytical.new_FORMResultCollection(*args))

# Register FORMResultCollection in _analytical:
_analytical.FORMResultCollection_swigregister(FORMResultCollection)
class MultiFORMResult(openturns.common.PersistentObject):
    r"""
    Multiple FORM result.

    Parameters
    ----------
    coll : sequence of :class:`~openturns.FORMResult`
        Collection of FORM results

    See also
    --------
    SystemFORM
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.MultiFORMResult_getClassName(self)

    def __repr__(self):
        return _analytical.MultiFORMResult___repr__(self)

    def setEventProbability(self, eventProbability):
        r"""
        Accessor to the failure probability :math:`P_f`.

        Parameters
        ----------
        probability : positive float
            The FORM failure probability :math:`P_f`.
        """
        return _analytical.MultiFORMResult_setEventProbability(self, eventProbability)

    def getEventProbability(self):
        r"""
        Accessor to the failure probability :math:`P_f`.

        Returns
        -------
        probability : positive float
            The FORM failure probability :math:`P_f`.
        """
        return _analytical.MultiFORMResult_getEventProbability(self)

    def getGeneralisedReliabilityIndex(self):
        r"""
        Accessor to the Generalised Reliability Index.

        Returns
        -------
        index : float
            Generalised reliability index :math:`\beta_g` from the FORM failure
            probability is equal to :math:`\pm` the Hasofer reliability index
            :math:`\beta_{HL}` according to the fact the standard space center
            fulfills the event or not.
        """
        return _analytical.MultiFORMResult_getGeneralisedReliabilityIndex(self)

    def getFORMResultCollection(self):
        r"""
        Accessor to the FORM results.

        Returns
        -------
        form_coll : collection of :class:`~openturns.FORMResult`
            Results of each sub FORM calculus.
        """
        return _analytical.MultiFORMResult_getFORMResultCollection(self)

    def __init__(self, *args):
        _analytical.MultiFORMResult_swiginit(self, _analytical.new_MultiFORMResult(*args))
    __swig_destroy__ = _analytical.delete_MultiFORMResult

# Register MultiFORMResult in _analytical:
_analytical.MultiFORMResult_swigregister(MultiFORMResult)
class SystemFORM(Analytical):
    r"""
    Approximation algorithm for system events based on FORM.

    Each event :math:`E_i` is represented by its reliability index :math:`\beta_i`
    and the hyperplane defined by the :math:`\vect{\alpha_i}` normal coefficients obtained via
    a preliminary FORM approximation.

    For an union (series systems) the probability writes:

    .. math::

        P(E_{sys}) = P(\bigcup_{i=1}^N E_i) = 1 - \Phi_k (\vect{\beta}; \vect{\vect{\rho}})

    where :math:`\vect{\vect{\rho}}_{i,j} = \vect{\alpha_i}^T\vect{\alpha_j}`

    For an intersection (parallel system) the probability writes:

    .. math::

        P(\bigcap_{i=1}^N E_i) = \Phi_k (-\vect{\beta}; \vect{\vect{\rho}})

    In practice the event has to be defined under its disjonctive normal form
    (union of intersections).
    Each probability of intersection region is computed using the previous formula,
    then the Poincare formula is used to combine each union:

    .. math::

        P(E_{sys}) = P(\bigcup_{i=1}^N E_i) = \sum_{i=1}^N P(E_i) - \sum_{i < j} P(E_i \cap E_j) + \dots + (-1)^N P(E_1 \cap E_2 \cap \dots \cap E_N)

    More details can be found in [lemaire2009]_, at the chapter *Reliability of systems*.

    Parameters
    ----------
    solver : :class:`~openturns.OptimizationAlgorithm`
        Optimization algorithm used to research the design point.
    event : :class:`~openturns.RandomVector`
        Failure system event, in disjunctive normal form
        (either a union of intersections, or a single intersection)
    physicalStartingPoint : sequence of float
        Starting point of the optimization algorithm, declared in the physical
        space.

    Notes
    -----
    As a leaf event may appear several times in the system event tree, and as a
    FORM calculus is run for each unique leaf event, there may be less items in the
    FORM results collection (returned by :meth:`~openturns.MultiFORMResult.getFORMResultCollection`) than leaf events.

    See also
    --------
    FORM, MultiFORMResult

    Examples
    --------
    >>> import openturns as ot
    >>> dim = 2
    >>> X = ot.RandomVector(ot.Normal(dim))
    >>> e1 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(['x1', 'x2'], ['(x1+2*x2)^2']), X), ot.Greater(), 5.0)
    >>> e2 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(['x1', 'x2'], ['(x2+3*x1)^2']), X), ot.Greater(), 5.0)
    >>> event = ot.IntersectionEvent([e1, e2])
    >>> solver = ot.AbdoRackwitz()
    >>> starting_pt = [0.1] * dim
    >>> algo = ot.SystemFORM(solver, event, starting_pt)
    >>> algo.run()
    >>> result = algo.getResult()
    >>> form_results = result.getFORMResultCollection()
    >>> pf = result.getEventProbability()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.SystemFORM_getClassName(self)

    def __repr__(self):
        return _analytical.SystemFORM___repr__(self)

    def setEvent(self, systemEvent):
        r"""
        Accessor to the event of which the probability is calculated.

        Parameters
        ----------
        event : :class:`~openturns.RandomVector`
            Event of which the probability is calculated.
        """
        return _analytical.SystemFORM_setEvent(self, systemEvent)

    def run(self):
        r"""
        Perform the research of the design point.

        Notes
        -----
        Performs the research of the design point and creates a
        :class:`~openturns.AnalyticalResult`, the structure result which is
        accessible with the method :meth:`getAnalyticalResult`.
        """
        return _analytical.SystemFORM_run(self)

    def getResult(self):
        r"""
        Accessor to the result.

        Returns
        -------
        result : :class:`~openturns.MultiFORMResult`
            Contains the global result as well as the sub FORM results.
        """
        return _analytical.SystemFORM_getResult(self)

    def __init__(self, *args):
        _analytical.SystemFORM_swiginit(self, _analytical.new_SystemFORM(*args))
    __swig_destroy__ = _analytical.delete_SystemFORM

# Register SystemFORM in _analytical:
_analytical.SystemFORM_swigregister(SystemFORM)
class MultiFORM(FORM):
    r"""
    FORM approximation with multiple design points.

    This algorithm searches for several design points by restarting the nearest-point search.
    For each design point we add a `bulge` function that penalizes the limit-state G around it:

    .. math::

        G_m(u) = G(u) + \sum_{i=1}^m B_i(u)

    The bulge function can be chosed as:

    .. math::

        B_i(u) = s_i (r_i^2 - \|u - u_i^{\ast}\|^2)^2

    Once these points are found a :ref:`form_approximation` is computed with each
    point and the probability of interest is computed as a series system
    probability: the union of the approximated events:

    .. math::

        P(E_{sys}) = P(\bigcup_{i=1}^N E_i) = 1 - \Phi_k (\vect{\beta}; \vect{\vect{\rho}})

    Beware, as with the regular FORM method the search can fail,
    or the enumeration of design can be not incomplete.

    More details can be found in [kiureghian1998]_.

    Parameters
    ----------
    solver : :class:`~openturns.OptimizationAlgorithm`
        Optimization algorithm used to research the design point.
    event : :class:`~openturns.RandomVector`
        Failure event
    physicalStartingPoint : sequence of float
        Starting point of the optimization algorithm, declared in the physical
        space.

    See also
    --------
    FORM, MultiFORMResult

    Examples
    --------
    >>> import openturns as ot
    >>> dim = 2
    >>> f = ot.SymbolicFunction(['x0', 'x1'], ['5.0-x1-0.5*(x0-0.1)^2'])
    >>> dist = ot.Normal(dim)
    >>> X = ot.RandomVector(dist)
    >>> Y = ot.CompositeRandomVector(f, X)
    >>> event = ot.ThresholdEvent(Y, ot.Less(), 0.0)
    >>> solver = ot.Cobyla()
    >>> starting_pt = dist.getMean()
    >>> algo = ot.MultiFORM(solver, event, starting_pt)
    >>> algo.run()
    >>> result = algo.getResult()
    >>> n_design_pts = len(result.getFORMResultCollection())
    >>> pf = result.getEventProbability()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _analytical.MultiFORM_getClassName(self)

    def getResult(self):
        r"""
        Accessor to the result.

        Returns
        -------
        result : :class:`~openturns.MultiFORMResult`
            Contains the global result as well as the sub FORM results.
        """
        return _analytical.MultiFORM_getResult(self)

    def setMaximumDesignPointsNumber(self, numberOfDesignPoints):
        r"""
        Accessor to the maximum number of design points.

        Parameters
        ----------
        max_dp : int
            Maximum number of design points
        """
        return _analytical.MultiFORM_setMaximumDesignPointsNumber(self, numberOfDesignPoints)

    def getMaximumDesignPointsNumber(self):
        r"""
        Accessor to the maximum number of design points.

        Returns
        -------
        max_dp : int
            Maximum number of design points
        """
        return _analytical.MultiFORM_getMaximumDesignPointsNumber(self)

    def __repr__(self):
        return _analytical.MultiFORM___repr__(self)

    def run(self):
        r"""
        Evaluate the failure probability.

        Notes
        -----
        Evaluate the failure probability and create a :class:`~openturns.FORMResult`,
        the structure result which is accessible with the method :meth:`getResult`.
        """
        return _analytical.MultiFORM_run(self)

    def __init__(self, *args):
        _analytical.MultiFORM_swiginit(self, _analytical.new_MultiFORM(*args))
    __swig_destroy__ = _analytical.delete_MultiFORM

# Register MultiFORM in _analytical:
_analytical.MultiFORM_swigregister(MultiFORM)

