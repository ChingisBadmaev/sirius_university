# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""Probabilistic meta-package."""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _uncertainty
else:
    import _uncertainty

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _uncertainty.delete_SwigPyIterator

    def value(self):
        return _uncertainty.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _uncertainty.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _uncertainty.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _uncertainty.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _uncertainty.SwigPyIterator_equal(self, x)

    def copy(self):
        return _uncertainty.SwigPyIterator_copy(self)

    def next(self):
        return _uncertainty.SwigPyIterator_next(self)

    def __next__(self):
        return _uncertainty.SwigPyIterator___next__(self)

    def previous(self):
        return _uncertainty.SwigPyIterator_previous(self)

    def advance(self, n):
        return _uncertainty.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _uncertainty.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _uncertainty.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _uncertainty.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _uncertainty.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _uncertainty.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _uncertainty.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _uncertainty:
_uncertainty.SwigPyIterator_swigregister(SwigPyIterator)
import openturns.base
import openturns.common
import openturns.typ
import openturns.statistics
import openturns.graph
import openturns.func
import openturns.geom
import openturns.iterative_statistics
import openturns.diff
import openturns.optim
import openturns.experiment
import openturns.solver
import openturns.algo
import openturns.model_copula
import openturns.randomvector
import openturns.dist_bundle1
import openturns.dist_bundle2
import openturns.weightedexperiment
import openturns.classification
import openturns.orthogonalbasis
import openturns.metamodel
class TaylorExpansionMoments(openturns.common.PersistentObject):
    r"""
    First and second order Taylor expansion formulas.

    Refer to :ref:`taylor_importance_factors`.

    Parameters
    ----------
    limitStateVariable : :class:`~openturns.RandomVector`
        It must be of type *Composite*, which means it must have
        been defined with the class :class:`~openturns.CompositeRandomVector`.

    Notes
    -----
    Assuming that :math:`\uX` has its two first moments finite and that :math:`h` is sufficiently regular,
    the Taylor expansion method is used to approximate the mean and variance of a random variable :math:`\uY = h(\uX)`
    with respect to the mean and variance of the input random vector :math:`\uX`.

    We note:

    - :math:`\mu_X = \Expect{\uX}` the mean of the random vector :math:`\uX`

    - :math:`\Cov \uX` the covariance matrix of the random vector :math:`\uX`. The
      elements are the followings :
      :math:`(\Cov \uX)_{ij} = \Expect{\left(X^i - \Expect{X^i} \right) \left(X^j - \Expect{X^j} \right) }`

    - :math:`\vect{\vect{\nabla}} h(\muX) = \: \Tr{\left( \frac{\partial y^i}{\partial x^j}\right)}_{\ux\: =\: \muX} = \: \Tr{\left( \frac{\partial h^i(\ux)}{\partial x^j}\right)}_{\ux\: =\: \muX}`
      is the transposed Jacobian matrix with :math:`i=1,\ldots,n_Y` and
      :math:`j=1,\ldots,n_X`.

    - :math:`\vect{\vect{\vect{\nabla^2}}} h(\ux\:,\ux)` is a tensor of order 3. It
      is composed by the second order derivative towards the :math:`i^\textrm{th}`
      and :math:`j^\textrm{th}` components of :math:`\ux` of the
      :math:`k^\textrm{th}` component of the output vector :math:`h(\ux)`. It
      yields to:
      :math:`\left( \nabla^2 h(\ux) \right)_{ijk} = \frac{\partial^2 (h^k(\ux))}{\partial x^i \partial x^j}`

    Then we have:

      .. math::

          <\vect{\vect{\nabla}}h(\muX) , \: \uX - \muX> = \sum_{j=1}^{n_X} \left( \frac{\partial {\uy}}{\partial {x^j}}\right)_{\ux = \muX} . \left( X^j-\muX^j \right)

    and

      .. math::

          <<\vect{\vect{\vect{\nabla }}}^2 h(\muX,\: \vect{\mu}_{X}),\: \uX - \muX>,\: \uX - \muX> = \left( \Tr{(\uX^i - \muX^i)}. \left(\frac{\partial^2 y^k}{\partial x^i \partial x^k}\right)_{\ux = \muX}. (\uX^j - \muX^j) \right)_{ijk}

    The Taylor expansion of order 2 of the model :math:`h` is:

    .. math::

        \uY = h(\muX) + <\vect{\vect{\nabla}}h(\muX) , \: \uX - \muX> + \frac{1}{2}<<\vect{\vect{\vect{\nabla }}}^2 h(\muX,\: \vect{\mu}_{\:X}),\: \uX - \muX>,\: \uX - \muX> + o(\Cov \uX)


    Depending on the order of the Taylor expansion (classically
    first order or second order), one can obtain different formulas introduced
    hereafter.

    **Approximation at the order 1:**

    Expectation:

    .. math::

        \Expect{\uY} \approx \vect{h}(\muX)

    Pay attention that :math:`\Expect{\uY}` is a vector. The :math:`k^\textrm{th}`
    component of this vector is equal to the :math:`k^\textrm{th}` component of the
    output vector computed by the model :math:`h` at the mean value.
    :math:`\Expect{\uY}` is thus the computation of the model at mean.

    Variance:

    .. math::

        \Cov \uY \approx \Tr{\vect{\vect{\nabla}}}\:\vect{h}(\muX).\Cov \uX.\vect{\vect{\nabla}}\:\vect{h}(\muX)

    **Approximation at the order 2:**

    Expectation:

    .. math::

        (\Expect{\uY})_k \approx (\vect{h}(\muX))_k +
                                  \left(
                                  \sum_{i=1}^{n_X}\frac{1}{2} (\Cov \uX)_{ii}.{(\nabla^2\:h(\uX))}_{iik} +
                                  \sum_{i=1}^{n_X} \sum_{j=1}^{i-1} (\Cov X)_{ij}.{(\nabla^2\:h(\uX))}_{ijk}
                                  \right)_k

    Variance:

    The decomposition of the variance at the order 2 is not implemented.
    It requires both the knowledge of higher order derivatives of the model and the
    knowledge of moments of order strictly greater than 2 of the PDF.

    Examples
    --------
    >>> import openturns as ot
    >>> ot.RandomGenerator.SetSeed(0)
    >>> myFunc = ot.SymbolicFunction(['x1', 'x2', 'x3', 'x4'],
    ...     ['(x1*x1+x2^3*x1)/(2*x3*x3+x4^4+1)', 'cos(x2*x2+x4)/(x1*x1+1+x3^4)'])
    >>> R = ot.CorrelationMatrix(4)
    >>> for i in range(4):
    ...     R[i, i - 1] = 0.25
    >>> distribution = ot.Normal([0.2]*4, [0.1, 0.2, 0.3, 0.4], R)
    >>> # We create a distribution-based RandomVector
    >>> X = ot.RandomVector(distribution)
    >>> # We create a composite RandomVector Y from X and myFunc
    >>> Y = ot.CompositeRandomVector(myFunc, X)
    >>> # We create a Taylor expansion method to approximate moments
    >>> myTaylorExpansionMoments = ot.TaylorExpansionMoments(Y)
    >>> print(myTaylorExpansionMoments.getMeanFirstOrder())
    [0.0384615,0.932544]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.TaylorExpansionMoments_getClassName(self)

    def __repr__(self):
        return _uncertainty.TaylorExpansionMoments___repr__(self)

    def getLimitStateVariable(self):
        r"""
        Get the limit state variable.

        Returns
        -------
        limitStateVariable : :class:`~openturns.RandomVector`
            Limit state variable.
        """
        return _uncertainty.TaylorExpansionMoments_getLimitStateVariable(self)

    def getMeanFirstOrder(self):
        r"""
        Get the approximation at the first order of the mean.

        Returns
        -------
        mean : :class:`~openturns.Point`
            Approximation at the first order of the mean of the random vector.
        """
        return _uncertainty.TaylorExpansionMoments_getMeanFirstOrder(self)

    def getMeanSecondOrder(self):
        r"""
        Get the approximation at the second order of the mean.

        Returns
        -------
        mean : :class:`~openturns.Point`
            Approximation at the second order of the mean of the random vector
            (it requires that the hessian of the Function has been defined).
        """
        return _uncertainty.TaylorExpansionMoments_getMeanSecondOrder(self)

    def getCovariance(self):
        r"""
        Get the approximation at the first order of the covariance matrix.

        Returns
        -------
        covariance : :class:`~openturns.CovarianceMatrix`
            Approximation at the first order of the covariance matrix of the random
            vector.
        """
        return _uncertainty.TaylorExpansionMoments_getCovariance(self)

    def getValueAtMean(self):
        r"""
        Get the value of the function.

        Returns
        -------
        value : :class:`~openturns.Point`
            Value of the Function which defines the random vector at
            the mean point of the input random vector.
        """
        return _uncertainty.TaylorExpansionMoments_getValueAtMean(self)

    def getGradientAtMean(self):
        r"""
        Get the gradient of the function.

        Returns
        -------
        gradient : :class:`~openturns.Matrix`
            Gradient of the Function which defines the random vector at
            the mean point of the input random vector.
        """
        return _uncertainty.TaylorExpansionMoments_getGradientAtMean(self)

    def getHessianAtMean(self):
        r"""
        Get the hessian of the function.

        Returns
        -------
        hessian : :class:`~openturns.SymmetricTensor`
            Hessian of the Function which defines the random vector at
            the mean point of the input random vector.
        """
        return _uncertainty.TaylorExpansionMoments_getHessianAtMean(self)

    def getImportanceFactors(self):
        r"""
        Get the importance factors.

        Returns
        -------
        factors : :class:`~openturns.Point`
            Importance factors of the inputs : only when randVect is of dimension 1.
        """
        return _uncertainty.TaylorExpansionMoments_getImportanceFactors(self)

    def drawImportanceFactors(self):
        r"""
        Draw the importance factors.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            Graph containing the pie corresponding to the importance factors of the
            probabilistic variables.
        """
        return _uncertainty.TaylorExpansionMoments_drawImportanceFactors(self)

    def __init__(self, *args):
        _uncertainty.TaylorExpansionMoments_swiginit(self, _uncertainty.new_TaylorExpansionMoments(*args))
    __swig_destroy__ = _uncertainty.delete_TaylorExpansionMoments

# Register TaylorExpansionMoments in _uncertainty:
_uncertainty.TaylorExpansionMoments_swigregister(TaylorExpansionMoments)
class EfficientGlobalOptimization(openturns.optim.OptimizationAlgorithmImplementation):
    r"""
    Efficient Global Optimization algorithm.

    The EGO algorithm [jones1998]_ is an adaptative optimization method based on
    kriging.
    An initial design of experiment is used to build a first metamodel.
    At each iteration a new point that maximizes a criterion is chosen as
    optimizer candidate.
    The criterion uses a tradeoff between the metamodel value and the conditional
    variance.
    Then the new point is evaluated using the original model and the metamodel is
    relearnt on the extended design of experiment.

    Parameters
    ----------
    problem : :class:`~openturns.OptimizationProblem`
        The optimization problem to solve
    krigingResult : :class:`~openturns.KrigingResult`
        The result of the meta-model on the first design of experiment
    noise : :class:`~openturns.Function`
        Noise model used on design experiment points, and also for improvement optimization

    Notes
    -----
    Each point added to the metamodel design seeks to improve the current minimum.
    We chose the point so as to maximize an improvement criterion based on the
    metamodel.

    .. math::

        I(x_{new}) = max(f_{min} - Y_{new}, 0)

    The default criteria is called EI (Expected Improvement) and aims at maximizing
    the mean improvement:

    .. math::

        \mathbb{E}\left[I(x_{new})\right] = \mathbb{E}\left[max(f_{min} - Y_{new}, 0)\right]

    This criterion is explicited using the kriging mean and variance:

    .. math::

        \mathbb{E}\left[I(x_{new})\right] = (f_{min} - m_K(x_{new})) \Phi\left( \frac{f_{min} - m_K(x_{new})}{s_K(x_{new})} \right) + s_K(x_{new}) \phi\left( \frac{f_{min} - m_K(x_{new})}{s_K(x_{new})} \right)

    An optional observation noise variance can be provided:

    .. math:: Y_{obs} = Y(x) + \sigma_{\epsilon}(x) \epsilon

    In that case the AEI (Augmented Expected Improvement) formulation is used.
    As we don't have access to the real minimum of the function anymore a quantile
    of the kriging prediction is used, with the constant :math:`c`:

    .. math:: u(x) = m_K(x) + c s_K(x)

    This criterion is minimized over the design points:

    .. math:: x_{min} = \argmax_{x_i} (u(x_i))

    The AEI criterion reads:

    .. math::

        AEI(x_{new}) = \mathbb{E}\left[max(m_K(x_{min}) - Y_{new}, 0)\right] \times \left(1 - \frac{\sigma_{\epsilon}(x_{new})}{\sqrt{\sigma_{\epsilon}^2(x_{new})+s^2_K(x_{new})}} \right)

    with

    .. math::

        \mathbb{E}\left[max(m_K(x_{min}) - Y_{new}, 0)\right] = (m_K(x_{min}) - m_K(x_{new})) \Phi\left( \frac{m_K(x_{min}) - m_K(x_{new})}{s_K(x_{new})} \right) + s_K(x_{new}) \phi\left( \frac{m_K(x_{min}) - m_K(x_{new})}{s_K(x_{new})} \right)

    A less computationally expensive noise function can be provided through
    :func:`setNoiseModel()` to evaluate :math:`\sigma^2_{\epsilon}(x)`
    for the improvement criterion optimization, the objective being only used to
    compute values and associated noise at design points.

    By default the criteria is minimized using :class:`~openturns.MultiStart`
    with starting points uniformly sampled in the optimization problem bounds,
    see :func:`setMultiStartExperimentSize` and :func:`setMultiStartNumber`.
    This behavior can be overridden by using another solver with :func:`setOptimizationAlgorithm`.

    Examples
    --------
    >>> import openturns as ot
    >>> ot.RandomGenerator.SetSeed(0)
    >>> dim = 4
    >>> model = ot.SymbolicFunction(['x1', 'x2', 'x3', 'x4'],
    ...     ['x1*x1+x2^3*x1+x3+x4'])
    >>> model = ot.MemoizeFunction(model)
    >>> bounds = ot.Interval([-5.0] * dim, [5.0] * dim)
    >>> problem = ot.OptimizationProblem()
    >>> problem.setObjective(model)
    >>> problem.setBounds(bounds)
    >>> experiment = ot.Composite([0.0] * dim, [1.0, 2.0, 4.0])
    >>> inputSample = experiment.generate()
    >>> outputSample = model(inputSample)
    >>> print('Initial minimum output value: ', outputSample.getMin())
    Initial minimum output value:  [-248]
    >>> covarianceModel = ot.SquaredExponential([2.0] * dim, [0.1])
    >>> basis = ot.ConstantBasisFactory(dim).build()
    >>> kriging = ot.KrigingAlgorithm(inputSample, outputSample, covarianceModel, basis)
    >>> kriging.run()
    >>> algo = ot.EfficientGlobalOptimization(problem, kriging.getResult())
    >>> algo.setMaximumEvaluationNumber(2)
    >>> algo.run()
    >>> result = algo.getResult()
    >>> updatedKrigingResult = algo.getKrigingResult()
    >>> updatedOutputSample = updatedKrigingResult.getOutputSample()
    >>> print('Updated minimum output value: ', updatedOutputSample.getMin())
    Updated minimum output value:  [-610]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.EfficientGlobalOptimization_getClassName(self)

    def __repr__(self):
        return _uncertainty.EfficientGlobalOptimization___repr__(self)

    def run(self):
        r"""Launch the optimization."""
        return _uncertainty.EfficientGlobalOptimization_run(self)

    def setOptimizationAlgorithm(self, solver):
        r"""
        Expected improvement solver accessor.

        Parameters
        ----------
        solver : :class:`~openturns.OptimizationSolver`
            The solver used to optimize the expected improvement
        """
        return _uncertainty.EfficientGlobalOptimization_setOptimizationAlgorithm(self, solver)

    def getOptimizationAlgorithm(self):
        r"""
        Expected improvement solver accessor.

        Returns
        -------
        solver : :class:`~openturns.OptimizationSolver`
            The solver used to optimize the expected improvement
        """
        return _uncertainty.EfficientGlobalOptimization_getOptimizationAlgorithm(self)

    def getMultiStartExperimentSize(self):
        r"""
        Size of the design to draw starting points.

        Returns
        -------
        multiStartExperimentSize : int
            The size of the Monte Carlo design from which to select the best starting
            points.
        """
        return _uncertainty.EfficientGlobalOptimization_getMultiStartExperimentSize(self)

    def setMultiStartExperimentSize(self, multiStartExperimentSize):
        r"""
        Size of the design to draw starting points.

        Parameters
        ----------
        multiStartExperimentSize : int
            The size of the Monte Carlo design from which to select the best starting
            points.
            The default number can be tweaked with the
            `EfficientGlobalOptimization-DefaultMultiStartExperimentSize` key from
            :class:`~openturns.ResourceMap`.
        """
        return _uncertainty.EfficientGlobalOptimization_setMultiStartExperimentSize(self, multiStartExperimentSize)

    def getMultiStartNumber(self):
        r"""
        Number of starting points for the criterion optimization.

        Returns
        -------
        multiStartNumber : int
            The number of starting points for the criterion optimization.
        """
        return _uncertainty.EfficientGlobalOptimization_getMultiStartNumber(self)

    def setMultiStartNumber(self, multiStartNumberSize):
        r"""
        Number of starting points for the criterion optimization.

        Parameters
        ----------
        multiStartNumber : int
            The number of starting points for the criterion optimization.
            The default number can be tweaked with the
            `EfficientGlobalOptimization-DefaultMultiStartNumber` key from
            :class:`~openturns.ResourceMap`.
        """
        return _uncertainty.EfficientGlobalOptimization_setMultiStartNumber(self, multiStartNumberSize)

    def getParameterEstimationPeriod(self):
        r"""
        Parameter estimation period accessor.

        Returns
        -------
        period : int
            The number of iterations between covariance parameters re-learn.
            Default is 1 (each iteration). Can be set to 0 (never).
        """
        return _uncertainty.EfficientGlobalOptimization_getParameterEstimationPeriod(self)

    def setParameterEstimationPeriod(self, parameterEstimationPeriod):
        r"""
        Parameter estimation period accessor.

        Parameters
        ----------
        period : int
            The number of iterations between covariance parameters re-learn.
            Default is 1 (each iteration). Can be set to 0 (never).
            The default number can be tweaked with the
            `EfficientGlobalOptimization-DefaultParameterEstimationPeriod` key from
            :class:`~openturns.ResourceMap`.
        """
        return _uncertainty.EfficientGlobalOptimization_setParameterEstimationPeriod(self, parameterEstimationPeriod)

    def setImprovementFactor(self, improvementFactor):
        r"""
        Improvement criterion factor accessor.

        Parameters
        ----------
        alpha : positive float, default=0.0 (disables the criterion)
            Used to define a stopping criterion on the improvement criterion:
            :math:`I_{max} < \alpha |Y_{min}|`
            with :math:`I_{max}` the current maximum of the improvement
            and :math:`Y_{min}` the current optimum.
        """
        return _uncertainty.EfficientGlobalOptimization_setImprovementFactor(self, improvementFactor)

    def getImprovementFactor(self):
        r"""
        Improvement criterion factor accessor.

        Returns
        -------
        alpha : positive float, default=0.0 (disables the criterion)
            Used to define a stopping criterion on the improvement criterion:
            :math:`I_{max} < \alpha |Y_{min}|`
            with :math:`I_{max}` the current maximum of the improvement
            and :math:`Y_{min}` the current optimum.
        """
        return _uncertainty.EfficientGlobalOptimization_getImprovementFactor(self)

    def setCorrelationLengthFactor(self, b):
        r"""
        Correlation length stopping criterion factor accessor.

        When a correlation length becomes smaller than the minimal distance between
        design point for a single component that means the model tends to be noisy,
        and the EGO formulation is not adapted anymore.

        Parameters
        ----------
        b : float
            Used to define a stopping criterion on the minimum correlation length:
            :math:`\theta_i < \frac{\Delta_i^{min}}{b}`
            with :math:`\Delta^{min}` the minimum distance between design points.
        """
        return _uncertainty.EfficientGlobalOptimization_setCorrelationLengthFactor(self, b)

    def getCorrelationLengthFactor(self):
        r"""
        Correlation length stopping criterion factor accessor.

        When a correlation length becomes smaller than the minimal distance between
        design point for a single component that means the model tends to be noisy,
        and the EGO formulation is not adapted anymore.

        Returns
        -------
        b : float
            Used to define a stopping criterion on the minimum correlation length:
            :math:`\theta_i < \frac{\Delta_i^{min}}{b}`
            with :math:`\Delta^{min}` the minimum distance between design points.
        """
        return _uncertainty.EfficientGlobalOptimization_getCorrelationLengthFactor(self)

    def setAEITradeoff(self, c):
        r"""
        AEI tradeoff constant accessor.

        Parameters
        ----------
        c : float
            Used to define a quantile of the kriging prediction at the design points.
            :math:`u(x)=m_K(x)+c*s_K(x)`
        """
        return _uncertainty.EfficientGlobalOptimization_setAEITradeoff(self, c)

    def getAEITradeoff(self):
        r"""
        AEI tradeoff constant accessor.

        Returns
        -------
        c : float
            Used to define a quantile of the kriging prediction at the design points.
            :math:`u(x)=m_K(x)+c*s_K(x)`
        """
        return _uncertainty.EfficientGlobalOptimization_getAEITradeoff(self)

    def setMetamodelNoise(self, metaModelNoise):
        r"""
        Metamodel noise model accessor.

        Parameters
        ----------
        noiseModel : :class:`~openturns.Function`
            The noise variance function :math:`\sigma^2_{\epsilon}(x)` used for the AEI
            design update only.
            Of same input dimension as the objective and 1-d output.
        """
        return _uncertainty.EfficientGlobalOptimization_setMetamodelNoise(self, metaModelNoise)

    def getMetamodelNoise(self):
        r"""
        Metamodel noise model accessor.

        Returns
        -------
        noiseModel : :class:`~openturns.Function`
            The noise variance function :math:`\sigma^2_{\epsilon}(x)` used for the AEI
            design update only.
            Of same input dimension as the objective and 1-d output.
        """
        return _uncertainty.EfficientGlobalOptimization_getMetamodelNoise(self)

    def setNoiseModel(self, noiseModel):
        r"""
        Improvement noise model accessor.

        Parameters
        ----------
        noiseModel : :class:`~openturns.Function`
            The noise variance function :math:`\sigma^2_{\epsilon}(x)` used for the AEI
            criterion optimization only.
            Of same input dimension as the objective and 1-d output.
        """
        return _uncertainty.EfficientGlobalOptimization_setNoiseModel(self, noiseModel)

    def getNoiseModel(self):
        r"""
        Improvement noise model accessor.

        Returns
        -------
        noiseModel : :class:`~openturns.Function`
            The noise variance function :math:`\sigma^2_{\epsilon}(x)` used for the AEI
            criterion optimization only.
            Of same input dimension as the objective and 1-d output.
        """
        return _uncertainty.EfficientGlobalOptimization_getNoiseModel(self)

    def getExpectedImprovement(self):
        r"""
        Expected improvement values.

        Returns
        -------
        ei : :class:`~openturns.Sample`
            The expected improvement optimal values.
        """
        return _uncertainty.EfficientGlobalOptimization_getExpectedImprovement(self)

    def getKrigingResult(self):
        r"""
        Retrieve the Kriging result.

        Notes
        -----
        Before :meth:`run` is called, this method returns the
        :class:`~openturns.KrigingResult` passed to the constructor.
        Once :meth:`run` has been called, it returns an updated
        :class:`~openturns.KrigingResult` that takes new observations into account.

        Returns
        -------
        krigingResult : :class:`~openturns.KrigingResult`
            Kriging result that takes all observations into account.
        """
        return _uncertainty.EfficientGlobalOptimization_getKrigingResult(self)

    def __init__(self, *args):
        _uncertainty.EfficientGlobalOptimization_swiginit(self, _uncertainty.new_EfficientGlobalOptimization(*args))
    __swig_destroy__ = _uncertainty.delete_EfficientGlobalOptimization

# Register EfficientGlobalOptimization in _uncertainty:
_uncertainty.EfficientGlobalOptimization_swigregister(EfficientGlobalOptimization)
import openturns.transformation
import openturns.analytical
import openturns.simulation
import openturns.stattests
import openturns.model_process
import openturns.dist_bundle3
class HSICStatImplementation(openturns.common.PersistentObject):
    r"""
    Base class of HSICStat.

    Notes
    -----
    This is a base class for the implementation of an HSIC statistic
    but cannot be used by itself. An HSIC statistic object can created by using the
    derived classes: :class:`~openturns.HSICUStat` and :class:`~openturns.HSICVStat`.

    See also
    --------
    :class:`~openturns.HSICUStat`, :class:`~openturns.HSICVStat`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICStatImplementation_getClassName(self)

    def computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix):
        r"""
        Compute the HSIC index between two samples.

        Parameters
        ----------
        inSample : 2-d sequence of float
            Input sample.

        outSample : 2-d sequence of float
            Output sample.

        inCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the input sample.

        outCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the output sample.

        weightMatrix : :class:`~openturns.Matrix`
            A weight matrix used for the statistic.

        Returns
        -------
        hsicIndex : the HSIC index of the two :class:`~openturns.Sample`.
        """
        return _uncertainty.HSICStatImplementation_computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix)

    def computePValue(self, dist, n, HSIC_obs, mHSIC):
        r"""
        Compute the p-value of the statistic.

        Parameters
        ----------
        dist : :class:`~openturns.Gamma`
            A :class:`~openturns.Gamma` distribution to compute the p-value.

        n : int
            The size of the samples.

        HSIC_obs : float
            The previously computed HSIC index.

        mHSIC : float
            Bias-correcting term (only actually used by U-statistics).

        Returns
        -------
        pvalue : the p-value of the statistic.
        """
        return _uncertainty.HSICStatImplementation_computePValue(self, dist, n, HSIC_obs, mHSIC)

    def isCompatibleWithConditionalAnalysis(self):
        r"""
        Indicate the compatibility with a conditional HSIC estimator.

        Returns
        -------
        isCompatible : bool
            Indicate the compatibility with a conditional HSIC estimator.
        """
        return _uncertainty.HSICStatImplementation_isCompatibleWithConditionalAnalysis(self)

    def __init__(self, *args):
        _uncertainty.HSICStatImplementation_swiginit(self, _uncertainty.new_HSICStatImplementation(*args))
    __swig_destroy__ = _uncertainty.delete_HSICStatImplementation

# Register HSICStatImplementation in _uncertainty:
_uncertainty.HSICStatImplementation_swigregister(HSICStatImplementation)
class HSICStatImplementationTypedInterfaceObject(openturns.common.InterfaceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _uncertainty.HSICStatImplementationTypedInterfaceObject_swiginit(self, _uncertainty.new_HSICStatImplementationTypedInterfaceObject(*args))

    def getImplementation(self):
        r"""
        Accessor to the underlying implementation.

        Returns
        -------
        impl : Implementation
            A copy of the underlying implementation object.
        """
        return _uncertainty.HSICStatImplementationTypedInterfaceObject_getImplementation(self)

    def setName(self, name):
        r"""
        Accessor to the object's name.

        Parameters
        ----------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICStatImplementationTypedInterfaceObject_setName(self, name)

    def getName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICStatImplementationTypedInterfaceObject_getName(self)

    def __eq__(self, other):
        return _uncertainty.HSICStatImplementationTypedInterfaceObject___eq__(self, other)

    def __ne__(self, other):
        return _uncertainty.HSICStatImplementationTypedInterfaceObject___ne__(self, other)
    __swig_destroy__ = _uncertainty.delete_HSICStatImplementationTypedInterfaceObject

# Register HSICStatImplementationTypedInterfaceObject in _uncertainty:
_uncertainty.HSICStatImplementationTypedInterfaceObject_swigregister(HSICStatImplementationTypedInterfaceObject)
class HSICStat(HSICStatImplementationTypedInterfaceObject):
    r"""
    Base class of HSICStat.

    Notes
    -----
    This is a base class for the implementation of an HSIC statistic
    but cannot be used by itself. An HSIC statistic object can created by using the
    derived classes: :class:`~openturns.HSICUStat` and :class:`~openturns.HSICVStat`.

    See also
    --------
    :class:`~openturns.HSICUStat`, :class:`~openturns.HSICVStat`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICStat_getClassName(self)

    def computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix):
        r"""
        Compute the HSIC index between two samples.

        Parameters
        ----------
        inSample : 2-d sequence of float
            Input sample.

        outSample : 2-d sequence of float
            Output sample.

        inCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the input sample.

        outCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the output sample.

        weightMatrix : :class:`~openturns.Matrix`
            A weight matrix used for the statistic.

        Returns
        -------
        hsicIndex : the HSIC index of the two :class:`~openturns.Sample`.
        """
        return _uncertainty.HSICStat_computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix)

    def computePValue(self, dist, n, HSIC_obs, mHSIC):
        r"""
        Compute the p-value of the statistic.

        Parameters
        ----------
        dist : :class:`~openturns.Gamma`
            A :class:`~openturns.Gamma` distribution to compute the p-value.

        n : int
            The size of the samples.

        HSIC_obs : float
            The previously computed HSIC index.

        mHSIC : float
            Bias-correcting term (only actually used by U-statistics).

        Returns
        -------
        pvalue : the p-value of the statistic.
        """
        return _uncertainty.HSICStat_computePValue(self, dist, n, HSIC_obs, mHSIC)

    def isCompatibleWithConditionalAnalysis(self):
        r"""
        Indicate the compatibility with a conditional HSIC estimator.

        Returns
        -------
        isCompatible : bool
            Indicate the compatibility with a conditional HSIC estimator.
        """
        return _uncertainty.HSICStat_isCompatibleWithConditionalAnalysis(self)

    def __init__(self, *args):
        _uncertainty.HSICStat_swiginit(self, _uncertainty.new_HSICStat(*args))
    __swig_destroy__ = _uncertainty.delete_HSICStat

# Register HSICStat in _uncertainty:
_uncertainty.HSICStat_swigregister(HSICStat)
class HSICUStat(HSICStatImplementation):
    r"""
    Unbiased HSIC statistics.

    Notes
    -----
    This an unbiased estimator for the computation of an HSIC index.

    See also
    --------
    :class:`~openturns.HSICVStat`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICUStat_getClassName(self)

    def computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix):
        r"""
        Compute the HSIC index between two samples.

        Parameters
        ----------
        inSample : 2-d sequence of float
            Input sample.

        outSample : 2-d sequence of float
            Output sample.

        inCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the input sample.

        outCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the output sample.

        weightMatrix : :class:`~openturns.Matrix`
            A weight matrix used for the statistic.

        Returns
        -------
        hsicIndex : the HSIC index of the two :class:`~openturns.Sample`.
        """
        return _uncertainty.HSICUStat_computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix)

    def computePValue(self, dist, n, HSIC_obs, mHSIC):
        r"""
        Compute the p-value of the statistic.

        Parameters
        ----------
        dist : :class:`~openturns.Gamma`
            A :class:`~openturns.Gamma` distribution to compute the p-value.

        n : int
            The size of the samples.

        HSIC_obs : float
            The previously computed HSIC index.

        mHSIC : float
            Bias-correcting term (only actually used by U-statistics).

        Returns
        -------
        pvalue : the p-value of the statistic.
        """
        return _uncertainty.HSICUStat_computePValue(self, dist, n, HSIC_obs, mHSIC)

    def isCompatibleWithConditionalAnalysis(self):
        r"""
        Indicate the compatibility with a conditional HSIC estimator.

        Returns
        -------
        isCompatible : bool
            Indicate the compatibility with a conditional HSIC estimator (false).
        """
        return _uncertainty.HSICUStat_isCompatibleWithConditionalAnalysis(self)

    def __init__(self, *args):
        _uncertainty.HSICUStat_swiginit(self, _uncertainty.new_HSICUStat(*args))
    __swig_destroy__ = _uncertainty.delete_HSICUStat

# Register HSICUStat in _uncertainty:
_uncertainty.HSICUStat_swigregister(HSICUStat)
class HSICVStat(HSICStatImplementation):
    r"""
    Biased HSIC statistics.

    Notes
    -----
    This a biased estimator for the computation of an HSIC index.

    See also
    --------
    :class:`~openturns.HSICUStat`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICVStat_getClassName(self)

    def computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix):
        r"""
        Compute the HSIC index between two samples.

        Parameters
        ----------
        inSample : 2-d sequence of float
            Input sample.

        outSample : 2-d sequence of float
            Output sample.

        inCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the input sample.

        outCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the output sample.

        weightMatrix : :class:`~openturns.Matrix`
            A weight matrix used for the statistic.

        Returns
        -------
        hsicIndex : the HSIC index of the two :class:`~openturns.Sample`.
        """
        return _uncertainty.HSICVStat_computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix)

    def computePValue(self, dist, n, HSIC_obs, mHSIC):
        r"""
        Compute the p-value of the statistic.

        Parameters
        ----------
        dist : :class:`~openturns.Gamma`
            A :class:`~openturns.Gamma` distribution to compute the p-value.

        n : int
            The size of the samples.

        HSIC_obs : float
            The previously computed HSIC index.

        mHSIC : float
            Bias-correcting term (only actually used by U-statistics).

        Returns
        -------
        pvalue : the p-value of the statistic.
        """
        return _uncertainty.HSICVStat_computePValue(self, dist, n, HSIC_obs, mHSIC)

    def isCompatibleWithConditionalAnalysis(self):
        r"""
        Indicate the compatibility with a conditional HSIC estimator.

        Returns
        -------
        isCompatible : bool
            Indicate the compatibility with a conditional HSIC estimator (true).
        """
        return _uncertainty.HSICVStat_isCompatibleWithConditionalAnalysis(self)

    def __init__(self, *args):
        _uncertainty.HSICVStat_swiginit(self, _uncertainty.new_HSICVStat(*args))
    __swig_destroy__ = _uncertainty.delete_HSICVStat

# Register HSICVStat in _uncertainty:
_uncertainty.HSICVStat_swigregister(HSICVStat)
class HSICEstimatorImplementation(openturns.common.PersistentObject):
    r"""
    Base class of HSIC estimators.

    Notes
    -----
    HSIC-based analyses must be performed by using the derived classes: :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorGlobalSensitivity` and :class:`~openturns.HSICEstimatorTargetSensitivity`.

    See also
    --------
    :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorGlobalSensitivity`, :class:`~openturns.HSICEstimatorTargetSensitivity`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimatorImplementation_getClassName(self)

    def setPermutationSize(self, B):
        r"""
        Set the number of permutations to be used for p-value estimate.

        Parameters
        ----------
        B : int
            The number of permutation used for p-value estimates.
        """
        return _uncertainty.HSICEstimatorImplementation_setPermutationSize(self, B)

    def getPermutationSize(self):
        r"""
        Get the number of permutations.

        Returns
        -------
        permutationSize : int
            The number of permutations.
        """
        return _uncertainty.HSICEstimatorImplementation_getPermutationSize(self)

    def getCovarianceModelCollection(self):
        r"""
        Get the list of all covariance models used.

        Returns
        -------
        coll : CovarianceModelCollection
            The list of all covariance models used. The last one is the output covariance model.
        """
        return _uncertainty.HSICEstimatorImplementation_getCovarianceModelCollection(self)

    def setCovarianceModelCollection(self, coll):
        r"""
        Set the covariance models.

        Parameters
        ----------
        coll : CovarianceModelCollection
            The list of all covariance models.
        """
        return _uncertainty.HSICEstimatorImplementation_setCovarianceModelCollection(self, coll)

    def getInputSample(self):
        r"""
        Get the input sample.

        Returns
        -------
        inSample : :class:`~openturns.Sample`
            The input sample used for analysis.
        """
        return _uncertainty.HSICEstimatorImplementation_getInputSample(self)

    def setInputSample(self, inputSample):
        r"""
        Set the input sample.

        Parameters
        ----------
        inputSample : 2-d sequence of float
            The input sample to be used.
        """
        return _uncertainty.HSICEstimatorImplementation_setInputSample(self, inputSample)

    def getOutputSample(self):
        r"""
        Get the output sample.

        Returns
        -------
        outSample : :class:`~openturns.Sample`
            The output sample used for analysis.
        """
        return _uncertainty.HSICEstimatorImplementation_getOutputSample(self)

    def setOutputSample(self, outputSample):
        r"""
        Set the output sample.

        Parameters
        ----------
        outputSample : 2-d sequence of float
            The output sample to be used.
        """
        return _uncertainty.HSICEstimatorImplementation_setOutputSample(self, outputSample)

    def getDimension(self):
        r"""
        Get the dimension of the input sample.

        Returns
        -------
        dim : int
            The dimension of the input sample.
        """
        return _uncertainty.HSICEstimatorImplementation_getDimension(self)

    def getSize(self):
        r"""
        Get the size of the input sample.

        Returns
        -------
        size : int
            The size of the input sample.
        """
        return _uncertainty.HSICEstimatorImplementation_getSize(self)

    def getEstimator(self):
        r"""
        Get the estimator used for computations.

        Returns
        -------
        estimator : :class:`~openturns.HSICStat`
            The estimator used for internal computations.
        """
        return _uncertainty.HSICEstimatorImplementation_getEstimator(self)

    def getHSICIndices(self):
        r"""
        Get the HSIC indices.

        Returns
        -------
        hsicIndices : :class:`~openturns.Point`
            The HSIC indices of all components.
        """
        return _uncertainty.HSICEstimatorImplementation_getHSICIndices(self)

    def getR2HSICIndices(self):
        r"""
        Get the R2-HSIC indices.

        Returns
        -------
        r2hsicIndices : :class:`~openturns.Point`
            The R2-HSIC indices of all components.
        """
        return _uncertainty.HSICEstimatorImplementation_getR2HSICIndices(self)

    def getPValuesPermutation(self):
        r"""
        Get the p-value estimated through permutations.

        Returns
        -------
        pval : :class:`~openturns.Point`
            The p-values of all components estimated with permutations of the data.
        """
        return _uncertainty.HSICEstimatorImplementation_getPValuesPermutation(self)

    def run(self):
        r"""Compute all values at once."""
        return _uncertainty.HSICEstimatorImplementation_run(self)

    def drawHSICIndices(self):
        r"""
        Draw the HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all HSIC indices according to components.
        """
        return _uncertainty.HSICEstimatorImplementation_drawHSICIndices(self)

    def drawR2HSICIndices(self):
        r"""
        Draw the R2-HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all R2-HSIC indices according to components.
        """
        return _uncertainty.HSICEstimatorImplementation_drawR2HSICIndices(self)

    def drawPValuesPermutation(self):
        r"""
        Draw the p-values obtained by permutation.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all p-values by permutation according to components.
        """
        return _uncertainty.HSICEstimatorImplementation_drawPValuesPermutation(self)

    def __init__(self, *args):
        _uncertainty.HSICEstimatorImplementation_swiginit(self, _uncertainty.new_HSICEstimatorImplementation(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorImplementation

# Register HSICEstimatorImplementation in _uncertainty:
_uncertainty.HSICEstimatorImplementation_swigregister(HSICEstimatorImplementation)
class HSICEstimatorImplementationTypedInterfaceObject(openturns.common.InterfaceObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _uncertainty.HSICEstimatorImplementationTypedInterfaceObject_swiginit(self, _uncertainty.new_HSICEstimatorImplementationTypedInterfaceObject(*args))

    def getImplementation(self):
        r"""
        Accessor to the underlying implementation.

        Returns
        -------
        impl : Implementation
            A copy of the underlying implementation object.
        """
        return _uncertainty.HSICEstimatorImplementationTypedInterfaceObject_getImplementation(self)

    def setName(self, name):
        r"""
        Accessor to the object's name.

        Parameters
        ----------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICEstimatorImplementationTypedInterfaceObject_setName(self, name)

    def getName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICEstimatorImplementationTypedInterfaceObject_getName(self)

    def __eq__(self, other):
        return _uncertainty.HSICEstimatorImplementationTypedInterfaceObject___eq__(self, other)

    def __ne__(self, other):
        return _uncertainty.HSICEstimatorImplementationTypedInterfaceObject___ne__(self, other)
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorImplementationTypedInterfaceObject

# Register HSICEstimatorImplementationTypedInterfaceObject in _uncertainty:
_uncertainty.HSICEstimatorImplementationTypedInterfaceObject_swigregister(HSICEstimatorImplementationTypedInterfaceObject)
class HSICEstimator(HSICEstimatorImplementationTypedInterfaceObject):
    r"""
    Base class of HSIC estimators.

    Notes
    -----
    HSIC-based analyses must be performed by using the derived classes: :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorGlobalSensitivity` and :class:`~openturns.HSICEstimatorTargetSensitivity`.

    See also
    --------
    :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorGlobalSensitivity`, :class:`~openturns.HSICEstimatorTargetSensitivity`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimator_getClassName(self)

    def getHSICIndices(self):
        r"""
        Get the HSIC indices.

        Returns
        -------
        hsicIndices : :class:`~openturns.Point`
            The HSIC indices of all components.
        """
        return _uncertainty.HSICEstimator_getHSICIndices(self)

    def getR2HSICIndices(self):
        r"""
        Get the R2-HSIC indices.

        Returns
        -------
        r2hsicIndices : :class:`~openturns.Point`
            The R2-HSIC indices of all components.
        """
        return _uncertainty.HSICEstimator_getR2HSICIndices(self)

    def getPValuesPermutation(self):
        r"""
        Get the p-value estimated through permutations.

        Returns
        -------
        pval : :class:`~openturns.Point`
            The p-values of all components estimated with permutations of the data.
        """
        return _uncertainty.HSICEstimator_getPValuesPermutation(self)

    def drawHSICIndices(self):
        r"""
        Draw the HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all HSIC indices according to components.
        """
        return _uncertainty.HSICEstimator_drawHSICIndices(self)

    def drawR2HSICIndices(self):
        r"""
        Draw the R2-HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all R2-HSIC indices according to components.
        """
        return _uncertainty.HSICEstimator_drawR2HSICIndices(self)

    def drawPValuesPermutation(self):
        r"""
        Draw the p-values obtained by permutation.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all p-values by permutation according to components.
        """
        return _uncertainty.HSICEstimator_drawPValuesPermutation(self)

    def setPermutationSize(self, B):
        r"""
        Set the number of permutations to be used for p-value estimate.

        Parameters
        ----------
        B : int
            The number of permutation used for p-value estimates.
        """
        return _uncertainty.HSICEstimator_setPermutationSize(self, B)

    def getPermutationSize(self):
        r"""
        Get the number of permutations.

        Returns
        -------
        permutationSize : int
            The number of permutations.
        """
        return _uncertainty.HSICEstimator_getPermutationSize(self)

    def getCovarianceModelCollection(self):
        r"""
        Get the list of all covariance models used.

        Returns
        -------
        coll : CovarianceModelCollection
            The list of all covariance models used. The last one is the output covariance model.
        """
        return _uncertainty.HSICEstimator_getCovarianceModelCollection(self)

    def setCovarianceModelCollection(self, coll):
        r"""
        Set the covariance models.

        Parameters
        ----------
        coll : CovarianceModelCollection
            The list of all covariance models.
        """
        return _uncertainty.HSICEstimator_setCovarianceModelCollection(self, coll)

    def getInputSample(self):
        r"""
        Get the input sample.

        Returns
        -------
        inSample : :class:`~openturns.Sample`
            The input sample used for analysis.
        """
        return _uncertainty.HSICEstimator_getInputSample(self)

    def setInputSample(self, inputSample):
        r"""
        Set the input sample.

        Parameters
        ----------
        inputSample : 2-d sequence of float
            The input sample to be used.
        """
        return _uncertainty.HSICEstimator_setInputSample(self, inputSample)

    def getOutputSample(self):
        r"""
        Get the output sample.

        Returns
        -------
        outSample : :class:`~openturns.Sample`
            The output sample used for analysis.
        """
        return _uncertainty.HSICEstimator_getOutputSample(self)

    def setOutputSample(self, outputSample):
        r"""
        Set the output sample.

        Parameters
        ----------
        outputSample : 2-d sequence of float
            The output sample to be used.
        """
        return _uncertainty.HSICEstimator_setOutputSample(self, outputSample)

    def getDimension(self):
        r"""
        Get the dimension of the input sample.

        Returns
        -------
        dim : int
            The dimension of the input sample.
        """
        return _uncertainty.HSICEstimator_getDimension(self)

    def getSize(self):
        r"""
        Get the size of the input sample.

        Returns
        -------
        size : int
            The size of the input sample.
        """
        return _uncertainty.HSICEstimator_getSize(self)

    def getEstimator(self):
        r"""
        Get the estimator used for computations.

        Returns
        -------
        estimator : :class:`~openturns.HSICStat`
            The estimator used for internal computations.
        """
        return _uncertainty.HSICEstimator_getEstimator(self)

    def __init__(self, *args):
        _uncertainty.HSICEstimator_swiginit(self, _uncertainty.new_HSICEstimator(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimator

# Register HSICEstimator in _uncertainty:
_uncertainty.HSICEstimator_swigregister(HSICEstimator)
class HSICEstimatorConditionalSensitivity(HSICEstimatorImplementation):
    r"""
    Implement a HSIC estimator for conditional analysis.

    Parameters
    ----------
    covarianceModelCollection : list of :class:`~openturns.CovarianceModel`
        List of all covariance kernels. The :math:`d` first kernels are linked to the input 
        and the last one is for the output.

    X : 2-d sequence of float
        The input sample used for the HSIC analysis of dimension :math:`d`.

    Y : 2-d sequence of float
        The output sample used for the HSIC analysis of dimension 1.

    weightFunction : :class:`~openturns.Function`
        A weight function used for the inputs.

    See also
    --------
    :class:`~openturns.HSICEstimatorGlobalSensitivity`, :class:`~openturns.HSICEstimatorTargetSensitivity`

    Notes
    -----
    Conditional sensitivity analysis relies on the :class:`~openturns.HSICVStat` estimator.

    Examples
    --------
    >>> import openturns as ot
    >>> from math import pi

    Generate input and output samples.

    >>> # 3d input distribution with an independent copula
    >>> distX = ot.ComposedDistribution([ot.Uniform(-pi, pi)] * 3)
    >>> X = distX.getSample(100) # get a sample
    >>>
    >>> # Apply the Ishigami model.
    >>> inputs = ['X1', 'X2', 'X3']
    >>> formula = ['sin(X1) + 5.0 * (sin(X2))^2 + 0.1 * X3^4 * sin(X1)']
    >>> modelIshigami = ot.SymbolicFunction(inputs, formula)
    >>> Y = modelIshigami(X) # Y = modelIshigami(X)

    Define covariance kernels for the model inputs.
    Put them in a list.

    >>> covarianceModelCollection = []
    >>> for i in range(3):
    ...     Xi = X.getMarginal(i)
    ...     Cov = ot.SquaredExponential(1)
    ...     Cov.setScale(Xi.computeStandardDeviation())
    ...     covarianceModelCollection.append(Cov)

    Append the list with the covariance kernel for the model output.

    >>> covarianceModelCollection.append(ot.SquaredExponential(Y.computeStandardDeviation()))

    To perform sensititivity analysis under the condition that the output belongs or is near a domain,
    define a weight function based on the distance to this domain.

    >>> dist = ot.DistanceToDomainFunction(ot.Interval(5, float('inf')))
    >>> func = ot.SymbolicFunction('x', 'exp(-0.5 * x)')
    >>> weight = ot.ComposedFunction(func, dist)

    Build and use the HSIC estimator for conditional sensitivity analysis.

    >>> hsic = ot.HSICEstimatorConditionalSensitivity(covarianceModelCollection, X, Y, weight)
    >>> print(hsic.getR2HSICIndices())
    [0.280788,0.00600014,0.0577616]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimatorConditionalSensitivity_getClassName(self)

    def getWeightFunction(self):
        r"""
        Get the weight function used.

        Returns
        -------
        weightFunction : :class:`~openturns.Function`
            The weight function used for the conditional estimator.
        """
        return _uncertainty.HSICEstimatorConditionalSensitivity_getWeightFunction(self)

    def setWeightFunction(self, weightFunction):
        r"""
        Set the weight function.

        Parameters
        ----------
        weightFunction : :class:`~openturns.Function`
            The weight function used for the conditional estimator.
        """
        return _uncertainty.HSICEstimatorConditionalSensitivity_setWeightFunction(self, weightFunction)

    def __init__(self, *args):
        _uncertainty.HSICEstimatorConditionalSensitivity_swiginit(self, _uncertainty.new_HSICEstimatorConditionalSensitivity(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorConditionalSensitivity

# Register HSICEstimatorConditionalSensitivity in _uncertainty:
_uncertainty.HSICEstimatorConditionalSensitivity_swigregister(HSICEstimatorConditionalSensitivity)
class HSICEstimatorGlobalSensitivity(HSICEstimatorImplementation):
    r"""
    Implement a HSIC estimator for global analysis.

    Parameters
    ----------
    covarianceModelCollection : list of :class:`~openturns.CovarianceModel`
        List of all covariance kernels. The :math:`d` first kernels are linked to the input 
        and the last one is for the output.

    X : 2-d sequence of float
        The input sample used for the HSIC analysis of dimension :math:`d`.

    Y : 2-d sequence of float
        The output sample used for the HSIC analysis of dimension 1.

    estimatorType : :class:`~openturns.HSICStat`
        An estimator for internal computations.

    See also
    --------
    :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorTargetSensitivity`

    Examples
    --------
    >>> import openturns as ot
    >>> from math import pi

    Generate input and output samples.

    >>> # 3d input distribution with an independent copula
    >>> distX = ot.ComposedDistribution([ot.Uniform(-pi, pi)] * 3)
    >>> X = distX.getSample(100) # get a sample
    >>>
    >>> # Apply the Ishigami model.
    >>> inputs = ['X1', 'X2', 'X3']
    >>> formula = ['sin(X1) + 5.0 * (sin(X2))^2 + 0.1 * X3^4 * sin(X1)']
    >>> modelIshigami = ot.SymbolicFunction(inputs, formula)
    >>> Y = modelIshigami(X) # Y = modelIshigami(X)

    Define covariance kernels for the model inputs.
    Put them in a list.

    >>> covarianceModelCollection = []
    >>> for i in range(3):
    ...     Xi = X.getMarginal(i)
    ...     Cov = ot.SquaredExponential(1)
    ...     Cov.setScale(Xi.computeStandardDeviation())
    ...     covarianceModelCollection.append(Cov)

    Append the list with the covariance kernel for the model output.

    >>> covarianceModelCollection.append(ot.SquaredExponential(Y.computeStandardDeviation()))

    Choose the statistic that will be used to estimate the HSIC indices.

    >>> estimatorType = ot.HSICUStat() # could be HSICVStat instead

    Build and use the HSIC estimator for global sensitivity analysis.

    >>> hsic = ot.HSICEstimatorGlobalSensitivity(covarianceModelCollection, X, Y, estimatorType)
    >>> print(hsic.getR2HSICIndices())
    [0.404051,0.0206756,0.0846069]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimatorGlobalSensitivity_getClassName(self)

    def getPValuesAsymptotic(self):
        r"""
        Get the p-values obtained with an asymptotic formula.

        Returns
        -------
        pval : sequence of float
            The p-values for all components.
        """
        return _uncertainty.HSICEstimatorGlobalSensitivity_getPValuesAsymptotic(self)

    def drawPValuesAsymptotic(self):
        r"""
        Draw the p-values obtained with an asymptotic formula.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all p-values estimated with an asymptotic formula.
        """
        return _uncertainty.HSICEstimatorGlobalSensitivity_drawPValuesAsymptotic(self)

    def run(self):
        r"""Compute all values at once."""
        return _uncertainty.HSICEstimatorGlobalSensitivity_run(self)

    def __init__(self, *args):
        _uncertainty.HSICEstimatorGlobalSensitivity_swiginit(self, _uncertainty.new_HSICEstimatorGlobalSensitivity(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorGlobalSensitivity

# Register HSICEstimatorGlobalSensitivity in _uncertainty:
_uncertainty.HSICEstimatorGlobalSensitivity_swigregister(HSICEstimatorGlobalSensitivity)
class HSICEstimatorTargetSensitivity(HSICEstimatorImplementation):
    r"""
    Implement a HSIC estimator for target analysis.

    Parameters
    ----------
    covarianceModelCollection : list of :class:`~openturns.CovarianceModel`
        List of all covariance kernels. The :math:`d` first kernels are linked to the input 
        and the last one is for the output.

    X : 2-d sequence of float
        The input sample used for the HSIC analysis of dimension :math:`d`.

    Y : 2-d sequence of float
        The output sample used for the HSIC analysis of dimension 1.

    estimatorType : :class:`~openturns.HSICStat`
        An estimator for internal computations.

    filterFunction : :class:`~openturns.Function`
        A filter function used for the output.

    See also
    --------
    :class:`~openturns.HSICEstimatorConditionalSensitivity`, :class:`~openturns.HSICEstimatorGlobalSensitivity`

    Examples
    --------
    >>> import openturns as ot
    >>> from math import pi

    Generate input and output samples.

    >>> # 3d input distribution with an independent copula
    >>> distX = ot.ComposedDistribution([ot.Uniform(-pi, pi)] * 3)
    >>> X = distX.getSample(100) # get a sample
    >>>
    >>> # Apply the Ishigami model.
    >>> inputs = ['X1', 'X2', 'X3']
    >>> formula = ['sin(X1) + 5.0 * (sin(X2))^2 + 0.1 * X3^4 * sin(X1)']
    >>> modelIshigami = ot.SymbolicFunction(inputs, formula)
    >>> Y = modelIshigami(X) # Y = modelIshigami(X)

    Define covariance kernels for the model inputs.
    Put them in a list.

    >>> covarianceModelCollection = []
    >>> for i in range(3):
    ...     Xi = X.getMarginal(i)
    ...     Cov = ot.SquaredExponential(1)
    ...     Cov.setScale(Xi.computeStandardDeviation())
    ...     covarianceModelCollection.append(Cov)

    Append the list with the covariance kernel for the model output.

    >>> covarianceModelCollection.append(ot.SquaredExponential(Y.computeStandardDeviation()))

    Choose the statistic that will be used to estimate the HSIC indices.

    >>> estimatorType = ot.HSICUStat() # could be HSICVStat instead

    Define a filter function to apply to the model output.

    >>> filter = ot.IndicatorFunction(ot.Interval(5, float('inf')))

    Build and use the HSIC estimator for target sensitivity analysis.

    >>> hsic = ot.HSICEstimatorTargetSensitivity(covarianceModelCollection, X, Y, estimatorType, filter)
    >>> print(hsic.getR2HSICIndices())
    [0.184124,-0.00585434,0.0339537]
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimatorTargetSensitivity_getClassName(self)

    def getPValuesAsymptotic(self):
        r"""
        Get the p-values estimated with an asymptotic formula.

        Returns
        -------
        pval : :class:`~openturns.Point`
            The p-values obtained with an asymptotic formula.
        """
        return _uncertainty.HSICEstimatorTargetSensitivity_getPValuesAsymptotic(self)

    def drawPValuesAsymptotic(self):
        r"""
        Draw the p-values obtained with an asymptotic formula.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all p-values obtained with an asymptotic formula.
        """
        return _uncertainty.HSICEstimatorTargetSensitivity_drawPValuesAsymptotic(self)

    def getFilterFunction(self):
        r"""
        Get the filter function used.

        Returns
        -------
        filterFunction : :class:`~openturns.Function`
            The filter function used for the target estimator.
        """
        return _uncertainty.HSICEstimatorTargetSensitivity_getFilterFunction(self)

    def setFilterFunction(self, filterFunction):
        r"""
        Set the filter function.

        Parameters
        ----------
        filterFunction : :class:`~openturns.Function`
            The filter function used for the target estimator.
        """
        return _uncertainty.HSICEstimatorTargetSensitivity_setFilterFunction(self, filterFunction)

    def run(self):
        r"""Compute all values at once."""
        return _uncertainty.HSICEstimatorTargetSensitivity_run(self)

    def __init__(self, *args):
        _uncertainty.HSICEstimatorTargetSensitivity_swiginit(self, _uncertainty.new_HSICEstimatorTargetSensitivity(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorTargetSensitivity

# Register HSICEstimatorTargetSensitivity in _uncertainty:
_uncertainty.HSICEstimatorTargetSensitivity_swigregister(HSICEstimatorTargetSensitivity)
class HSICStatImplementationPointer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    ptr_ = property(_uncertainty.HSICStatImplementationPointer_ptr__get, _uncertainty.HSICStatImplementationPointer_ptr__set)

    def __init__(self, *args):
        _uncertainty.HSICStatImplementationPointer_swiginit(self, _uncertainty.new_HSICStatImplementationPointer(*args))
    __swig_destroy__ = _uncertainty.delete_HSICStatImplementationPointer

    def reset(self):
        return _uncertainty.HSICStatImplementationPointer_reset(self)

    def __ref__(self, *args):
        return _uncertainty.HSICStatImplementationPointer___ref__(self, *args)

    def __deref__(self, *args):
        return _uncertainty.HSICStatImplementationPointer___deref__(self, *args)

    def isNull(self):
        return _uncertainty.HSICStatImplementationPointer_isNull(self)

    def __nonzero__(self):
        return _uncertainty.HSICStatImplementationPointer___nonzero__(self)
    __bool__ = __nonzero__



    def get(self):
        return _uncertainty.HSICStatImplementationPointer_get(self)

    def getImplementation(self):
        return _uncertainty.HSICStatImplementationPointer_getImplementation(self)

    def unique(self):
        return _uncertainty.HSICStatImplementationPointer_unique(self)

    def use_count(self):
        return _uncertainty.HSICStatImplementationPointer_use_count(self)

    def swap(self, other):
        return _uncertainty.HSICStatImplementationPointer_swap(self, other)

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICStatImplementationPointer_getClassName(self)

    def computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix):
        r"""
        Compute the HSIC index between two samples.

        Parameters
        ----------
        inSample : 2-d sequence of float
            Input sample.

        outSample : 2-d sequence of float
            Output sample.

        inCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the input sample.

        outCovariance : :class:`~openturns.CovarianceModel`
            The covariance model associated with the output sample.

        weightMatrix : :class:`~openturns.Matrix`
            A weight matrix used for the statistic.

        Returns
        -------
        hsicIndex : the HSIC index of the two :class:`~openturns.Sample`.
        """
        return _uncertainty.HSICStatImplementationPointer_computeHSICIndex(self, inSample, outSample, inCovariance, outCovariance, weightMatrix)

    def computePValue(self, dist, n, HSIC_obs, mHSIC):
        r"""
        Compute the p-value of the statistic.

        Parameters
        ----------
        dist : :class:`~openturns.Gamma`
            A :class:`~openturns.Gamma` distribution to compute the p-value.

        n : int
            The size of the samples.

        HSIC_obs : float
            The previously computed HSIC index.

        mHSIC : float
            Bias-correcting term (only actually used by U-statistics).

        Returns
        -------
        pvalue : the p-value of the statistic.
        """
        return _uncertainty.HSICStatImplementationPointer_computePValue(self, dist, n, HSIC_obs, mHSIC)

    def isCompatibleWithConditionalAnalysis(self):
        r"""
        Indicate the compatibility with a conditional HSIC estimator.

        Returns
        -------
        isCompatible : bool
            Indicate the compatibility with a conditional HSIC estimator.
        """
        return _uncertainty.HSICStatImplementationPointer_isCompatibleWithConditionalAnalysis(self)

    def __eq__(self, arg2):
        return _uncertainty.HSICStatImplementationPointer___eq__(self, arg2)

    def __ne__(self, other):
        return _uncertainty.HSICStatImplementationPointer___ne__(self, other)

    def __repr__(self):
        return _uncertainty.HSICStatImplementationPointer___repr__(self)

    def __str__(self, *args):
        return _uncertainty.HSICStatImplementationPointer___str__(self, *args)

    def getId(self):
        r"""
        Accessor to the object's id.

        Returns
        -------
        id : int
           Internal unique identifier.
        """
        return _uncertainty.HSICStatImplementationPointer_getId(self)

    def setShadowedId(self, id):
        r"""
        Accessor to the object's shadowed id.

        Parameters
        ----------
        id : int
            Internal unique identifier.
        """
        return _uncertainty.HSICStatImplementationPointer_setShadowedId(self, id)

    def getShadowedId(self):
        r"""
        Accessor to the object's shadowed id.

        Returns
        -------
        id : int
            Internal unique identifier.
        """
        return _uncertainty.HSICStatImplementationPointer_getShadowedId(self)

    def setVisibility(self, visible):
        r"""
        Accessor to the object's visibility state.

        Parameters
        ----------
        visible : bool
            Visibility flag.
        """
        return _uncertainty.HSICStatImplementationPointer_setVisibility(self, visible)

    def getVisibility(self):
        r"""
        Accessor to the object's visibility state.

        Returns
        -------
        visible : bool
            Visibility flag.
        """
        return _uncertainty.HSICStatImplementationPointer_getVisibility(self)

    def hasName(self):
        r"""
        Test if the object is named.

        Returns
        -------
        hasName : bool
            True if the name is not empty.
        """
        return _uncertainty.HSICStatImplementationPointer_hasName(self)

    def hasVisibleName(self):
        r"""
        Test if the object has a distinguishable name.

        Returns
        -------
        hasVisibleName : bool
            True if the name is not empty and not the default one.
        """
        return _uncertainty.HSICStatImplementationPointer_hasVisibleName(self)

    def getName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICStatImplementationPointer_getName(self)

    def setName(self, name):
        r"""
        Accessor to the object's name.

        Parameters
        ----------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICStatImplementationPointer_setName(self, name)

# Register HSICStatImplementationPointer in _uncertainty:
_uncertainty.HSICStatImplementationPointer_swigregister(HSICStatImplementationPointer)
class HSICEstimatorImplementationPointer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    ptr_ = property(_uncertainty.HSICEstimatorImplementationPointer_ptr__get, _uncertainty.HSICEstimatorImplementationPointer_ptr__set)

    def __init__(self, *args):
        _uncertainty.HSICEstimatorImplementationPointer_swiginit(self, _uncertainty.new_HSICEstimatorImplementationPointer(*args))
    __swig_destroy__ = _uncertainty.delete_HSICEstimatorImplementationPointer

    def reset(self):
        return _uncertainty.HSICEstimatorImplementationPointer_reset(self)

    def __ref__(self, *args):
        return _uncertainty.HSICEstimatorImplementationPointer___ref__(self, *args)

    def __deref__(self, *args):
        return _uncertainty.HSICEstimatorImplementationPointer___deref__(self, *args)

    def isNull(self):
        return _uncertainty.HSICEstimatorImplementationPointer_isNull(self)

    def __nonzero__(self):
        return _uncertainty.HSICEstimatorImplementationPointer___nonzero__(self)
    __bool__ = __nonzero__



    def get(self):
        return _uncertainty.HSICEstimatorImplementationPointer_get(self)

    def getImplementation(self):
        return _uncertainty.HSICEstimatorImplementationPointer_getImplementation(self)

    def unique(self):
        return _uncertainty.HSICEstimatorImplementationPointer_unique(self)

    def use_count(self):
        return _uncertainty.HSICEstimatorImplementationPointer_use_count(self)

    def swap(self, other):
        return _uncertainty.HSICEstimatorImplementationPointer_swap(self, other)

    def getClassName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        class_name : str
            The object class name (`object.__class__.__name__`).
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getClassName(self)

    def setPermutationSize(self, B):
        r"""
        Set the number of permutations to be used for p-value estimate.

        Parameters
        ----------
        B : int
            The number of permutation used for p-value estimates.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setPermutationSize(self, B)

    def getPermutationSize(self):
        r"""
        Get the number of permutations.

        Returns
        -------
        permutationSize : int
            The number of permutations.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getPermutationSize(self)

    def getCovarianceModelCollection(self):
        r"""
        Get the list of all covariance models used.

        Returns
        -------
        coll : CovarianceModelCollection
            The list of all covariance models used. The last one is the output covariance model.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getCovarianceModelCollection(self)

    def setCovarianceModelCollection(self, coll):
        r"""
        Set the covariance models.

        Parameters
        ----------
        coll : CovarianceModelCollection
            The list of all covariance models.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setCovarianceModelCollection(self, coll)

    def getInputSample(self):
        r"""
        Get the input sample.

        Returns
        -------
        inSample : :class:`~openturns.Sample`
            The input sample used for analysis.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getInputSample(self)

    def setInputSample(self, inputSample):
        r"""
        Set the input sample.

        Parameters
        ----------
        inputSample : 2-d sequence of float
            The input sample to be used.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setInputSample(self, inputSample)

    def getOutputSample(self):
        r"""
        Get the output sample.

        Returns
        -------
        outSample : :class:`~openturns.Sample`
            The output sample used for analysis.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getOutputSample(self)

    def setOutputSample(self, outputSample):
        r"""
        Set the output sample.

        Parameters
        ----------
        outputSample : 2-d sequence of float
            The output sample to be used.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setOutputSample(self, outputSample)

    def getDimension(self):
        r"""
        Get the dimension of the input sample.

        Returns
        -------
        dim : int
            The dimension of the input sample.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getDimension(self)

    def getSize(self):
        r"""
        Get the size of the input sample.

        Returns
        -------
        size : int
            The size of the input sample.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getSize(self)

    def getEstimator(self):
        r"""
        Get the estimator used for computations.

        Returns
        -------
        estimator : :class:`~openturns.HSICStat`
            The estimator used for internal computations.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getEstimator(self)

    def getHSICIndices(self):
        r"""
        Get the HSIC indices.

        Returns
        -------
        hsicIndices : :class:`~openturns.Point`
            The HSIC indices of all components.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getHSICIndices(self)

    def getR2HSICIndices(self):
        r"""
        Get the R2-HSIC indices.

        Returns
        -------
        r2hsicIndices : :class:`~openturns.Point`
            The R2-HSIC indices of all components.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getR2HSICIndices(self)

    def getPValuesPermutation(self):
        r"""
        Get the p-value estimated through permutations.

        Returns
        -------
        pval : :class:`~openturns.Point`
            The p-values of all components estimated with permutations of the data.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getPValuesPermutation(self)

    def run(self):
        r"""Compute all values at once."""
        return _uncertainty.HSICEstimatorImplementationPointer_run(self)

    def drawHSICIndices(self):
        r"""
        Draw the HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all HSIC indices according to components.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_drawHSICIndices(self)

    def drawR2HSICIndices(self):
        r"""
        Draw the R2-HSIC indices.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all R2-HSIC indices according to components.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_drawR2HSICIndices(self)

    def drawPValuesPermutation(self):
        r"""
        Draw the p-values obtained by permutation.

        Returns
        -------
        graph : :class:`~openturns.Graph`
            The graph of all p-values by permutation according to components.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_drawPValuesPermutation(self)

    def __eq__(self, arg2):
        return _uncertainty.HSICEstimatorImplementationPointer___eq__(self, arg2)

    def __ne__(self, other):
        return _uncertainty.HSICEstimatorImplementationPointer___ne__(self, other)

    def __repr__(self):
        return _uncertainty.HSICEstimatorImplementationPointer___repr__(self)

    def __str__(self, *args):
        return _uncertainty.HSICEstimatorImplementationPointer___str__(self, *args)

    def getId(self):
        r"""
        Accessor to the object's id.

        Returns
        -------
        id : int
           Internal unique identifier.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getId(self)

    def setShadowedId(self, id):
        r"""
        Accessor to the object's shadowed id.

        Parameters
        ----------
        id : int
            Internal unique identifier.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setShadowedId(self, id)

    def getShadowedId(self):
        r"""
        Accessor to the object's shadowed id.

        Returns
        -------
        id : int
            Internal unique identifier.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getShadowedId(self)

    def setVisibility(self, visible):
        r"""
        Accessor to the object's visibility state.

        Parameters
        ----------
        visible : bool
            Visibility flag.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setVisibility(self, visible)

    def getVisibility(self):
        r"""
        Accessor to the object's visibility state.

        Returns
        -------
        visible : bool
            Visibility flag.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getVisibility(self)

    def hasName(self):
        r"""
        Test if the object is named.

        Returns
        -------
        hasName : bool
            True if the name is not empty.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_hasName(self)

    def hasVisibleName(self):
        r"""
        Test if the object has a distinguishable name.

        Returns
        -------
        hasVisibleName : bool
            True if the name is not empty and not the default one.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_hasVisibleName(self)

    def getName(self):
        r"""
        Accessor to the object's name.

        Returns
        -------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_getName(self)

    def setName(self, name):
        r"""
        Accessor to the object's name.

        Parameters
        ----------
        name : str
            The name of the object.
        """
        return _uncertainty.HSICEstimatorImplementationPointer_setName(self, name)

# Register HSICEstimatorImplementationPointer in _uncertainty:
_uncertainty.HSICEstimatorImplementationPointer_swigregister(HSICEstimatorImplementationPointer)

